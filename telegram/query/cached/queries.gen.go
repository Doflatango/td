// Code generated by itergen, DO NOT EDIT.

package cached

import (
	"context"
	"sync/atomic"

	"golang.org/x/xerrors"

	"github.com/gotd/td/tg"
)

// No-op definition for keeping imports.
var _ = context.Background()

type innerAccountGetThemes struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.AccountThemes
}

type AccountGetThemes struct {
	// Additional parameters, must be immutable.
	paramFormat string

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewAccountGetThemes creates new AccountGetThemes.
func NewAccountGetThemes(raw *tg.Client, paramFormat string) *AccountGetThemes {
	q := &AccountGetThemes{
		paramFormat: paramFormat,
		acquire:     make(chan struct{}, 1),
		raw:         raw,
	}

	return q
}

func (s *AccountGetThemes) store(v innerAccountGetThemes) {
	s.last.Store(v)
}

func (s *AccountGetThemes) load() (innerAccountGetThemes, bool) {
	v, ok := s.last.Load().(innerAccountGetThemes)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned AccountThemes must not be mutated.
func (s *AccountGetThemes) Value() *tg.AccountThemes {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *AccountGetThemes) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *AccountGetThemes) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := &tg.AccountGetThemesRequest{
		Format: s.paramFormat,
		Hash:   lastHash,
	}
	result, err := s.raw.AccountGetThemes(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute AccountGetThemes: %w", err)
	}

	switch variant := result.(type) {
	case *tg.AccountThemes:
		hash := variant.Hash

		s.store(innerAccountGetThemes{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.AccountThemesNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerAccountGetWallPapers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.AccountWallPapers
}

type AccountGetWallPapers struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewAccountGetWallPapers creates new AccountGetWallPapers.
func NewAccountGetWallPapers(raw *tg.Client) *AccountGetWallPapers {
	q := &AccountGetWallPapers{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *AccountGetWallPapers) store(v innerAccountGetWallPapers) {
	s.last.Store(v)
}

func (s *AccountGetWallPapers) load() (innerAccountGetWallPapers, bool) {
	v, ok := s.last.Load().(innerAccountGetWallPapers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned AccountWallPapers must not be mutated.
func (s *AccountGetWallPapers) Value() *tg.AccountWallPapers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *AccountGetWallPapers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *AccountGetWallPapers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.AccountGetWallPapers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute AccountGetWallPapers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.AccountWallPapers:
		hash := variant.Hash

		s.store(innerAccountGetWallPapers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.AccountWallPapersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerContactsGetContacts struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.ContactsContacts
}

type ContactsGetContacts struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewContactsGetContacts creates new ContactsGetContacts.
func NewContactsGetContacts(raw *tg.Client) *ContactsGetContacts {
	q := &ContactsGetContacts{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *ContactsGetContacts) store(v innerContactsGetContacts) {
	s.last.Store(v)
}

func (s *ContactsGetContacts) load() (innerContactsGetContacts, bool) {
	v, ok := s.last.Load().(innerContactsGetContacts)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned ContactsContacts must not be mutated.
func (s *ContactsGetContacts) Value() *tg.ContactsContacts {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *ContactsGetContacts) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *ContactsGetContacts) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.ContactsGetContacts(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute ContactsGetContacts: %w", err)
	}

	switch variant := result.(type) {
	case *tg.ContactsContacts:
		hash := s.computeHash(variant)

		s.store(innerContactsGetContacts{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.ContactsContactsNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerHelpGetCountriesList struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.HelpCountriesList
}

type HelpGetCountriesList struct {
	// Additional parameters, must be immutable.
	paramLangCode string

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewHelpGetCountriesList creates new HelpGetCountriesList.
func NewHelpGetCountriesList(raw *tg.Client, paramLangCode string) *HelpGetCountriesList {
	q := &HelpGetCountriesList{
		paramLangCode: paramLangCode,
		acquire:       make(chan struct{}, 1),
		raw:           raw,
	}

	return q
}

func (s *HelpGetCountriesList) store(v innerHelpGetCountriesList) {
	s.last.Store(v)
}

func (s *HelpGetCountriesList) load() (innerHelpGetCountriesList, bool) {
	v, ok := s.last.Load().(innerHelpGetCountriesList)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned HelpCountriesList must not be mutated.
func (s *HelpGetCountriesList) Value() *tg.HelpCountriesList {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *HelpGetCountriesList) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *HelpGetCountriesList) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := &tg.HelpGetCountriesListRequest{
		LangCode: s.paramLangCode,
		Hash:     lastHash,
	}
	result, err := s.raw.HelpGetCountriesList(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute HelpGetCountriesList: %w", err)
	}

	switch variant := result.(type) {
	case *tg.HelpCountriesList:
		hash := variant.Hash

		s.store(innerHelpGetCountriesList{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.HelpCountriesListNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerHelpGetPassportConfig struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.HelpPassportConfig
}

type HelpGetPassportConfig struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewHelpGetPassportConfig creates new HelpGetPassportConfig.
func NewHelpGetPassportConfig(raw *tg.Client) *HelpGetPassportConfig {
	q := &HelpGetPassportConfig{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *HelpGetPassportConfig) store(v innerHelpGetPassportConfig) {
	s.last.Store(v)
}

func (s *HelpGetPassportConfig) load() (innerHelpGetPassportConfig, bool) {
	v, ok := s.last.Load().(innerHelpGetPassportConfig)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned HelpPassportConfig must not be mutated.
func (s *HelpGetPassportConfig) Value() *tg.HelpPassportConfig {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *HelpGetPassportConfig) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *HelpGetPassportConfig) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.HelpGetPassportConfig(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute HelpGetPassportConfig: %w", err)
	}

	switch variant := result.(type) {
	case *tg.HelpPassportConfig:
		hash := variant.Hash

		s.store(innerHelpGetPassportConfig{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.HelpPassportConfigNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetAllStickers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesAllStickers
}

type MessagesGetAllStickers struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetAllStickers creates new MessagesGetAllStickers.
func NewMessagesGetAllStickers(raw *tg.Client) *MessagesGetAllStickers {
	q := &MessagesGetAllStickers{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *MessagesGetAllStickers) store(v innerMessagesGetAllStickers) {
	s.last.Store(v)
}

func (s *MessagesGetAllStickers) load() (innerMessagesGetAllStickers, bool) {
	v, ok := s.last.Load().(innerMessagesGetAllStickers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesAllStickers must not be mutated.
func (s *MessagesGetAllStickers) Value() *tg.MessagesAllStickers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetAllStickers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetAllStickers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.MessagesGetAllStickers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetAllStickers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesAllStickers:
		hash := variant.Hash

		s.store(innerMessagesGetAllStickers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesAllStickersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetFavedStickers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesFavedStickers
}

type MessagesGetFavedStickers struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetFavedStickers creates new MessagesGetFavedStickers.
func NewMessagesGetFavedStickers(raw *tg.Client) *MessagesGetFavedStickers {
	q := &MessagesGetFavedStickers{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *MessagesGetFavedStickers) store(v innerMessagesGetFavedStickers) {
	s.last.Store(v)
}

func (s *MessagesGetFavedStickers) load() (innerMessagesGetFavedStickers, bool) {
	v, ok := s.last.Load().(innerMessagesGetFavedStickers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesFavedStickers must not be mutated.
func (s *MessagesGetFavedStickers) Value() *tg.MessagesFavedStickers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetFavedStickers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetFavedStickers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.MessagesGetFavedStickers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetFavedStickers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesFavedStickers:
		hash := variant.Hash

		s.store(innerMessagesGetFavedStickers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesFavedStickersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetFeaturedStickers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesFeaturedStickers
}

type MessagesGetFeaturedStickers struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetFeaturedStickers creates new MessagesGetFeaturedStickers.
func NewMessagesGetFeaturedStickers(raw *tg.Client) *MessagesGetFeaturedStickers {
	q := &MessagesGetFeaturedStickers{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *MessagesGetFeaturedStickers) store(v innerMessagesGetFeaturedStickers) {
	s.last.Store(v)
}

func (s *MessagesGetFeaturedStickers) load() (innerMessagesGetFeaturedStickers, bool) {
	v, ok := s.last.Load().(innerMessagesGetFeaturedStickers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesFeaturedStickers must not be mutated.
func (s *MessagesGetFeaturedStickers) Value() *tg.MessagesFeaturedStickers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetFeaturedStickers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetFeaturedStickers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.MessagesGetFeaturedStickers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetFeaturedStickers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesFeaturedStickers:
		hash := variant.Hash

		s.store(innerMessagesGetFeaturedStickers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesFeaturedStickersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetMaskStickers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesAllStickers
}

type MessagesGetMaskStickers struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetMaskStickers creates new MessagesGetMaskStickers.
func NewMessagesGetMaskStickers(raw *tg.Client) *MessagesGetMaskStickers {
	q := &MessagesGetMaskStickers{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *MessagesGetMaskStickers) store(v innerMessagesGetMaskStickers) {
	s.last.Store(v)
}

func (s *MessagesGetMaskStickers) load() (innerMessagesGetMaskStickers, bool) {
	v, ok := s.last.Load().(innerMessagesGetMaskStickers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesAllStickers must not be mutated.
func (s *MessagesGetMaskStickers) Value() *tg.MessagesAllStickers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetMaskStickers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetMaskStickers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.MessagesGetMaskStickers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetMaskStickers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesAllStickers:
		hash := variant.Hash

		s.store(innerMessagesGetMaskStickers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesAllStickersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetRecentStickers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesRecentStickers
}

type MessagesGetRecentStickers struct {
	// Additional parameters, must be immutable.
	paramAttached bool

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetRecentStickers creates new MessagesGetRecentStickers.
func NewMessagesGetRecentStickers(raw *tg.Client, paramAttached bool) *MessagesGetRecentStickers {
	q := &MessagesGetRecentStickers{
		paramAttached: paramAttached,
		acquire:       make(chan struct{}, 1),
		raw:           raw,
	}

	return q
}

func (s *MessagesGetRecentStickers) store(v innerMessagesGetRecentStickers) {
	s.last.Store(v)
}

func (s *MessagesGetRecentStickers) load() (innerMessagesGetRecentStickers, bool) {
	v, ok := s.last.Load().(innerMessagesGetRecentStickers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesRecentStickers must not be mutated.
func (s *MessagesGetRecentStickers) Value() *tg.MessagesRecentStickers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetRecentStickers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetRecentStickers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := &tg.MessagesGetRecentStickersRequest{
		Attached: s.paramAttached,
		Hash:     lastHash,
	}
	result, err := s.raw.MessagesGetRecentStickers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetRecentStickers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesRecentStickers:
		hash := variant.Hash

		s.store(innerMessagesGetRecentStickers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesRecentStickersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetSavedGifs struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesSavedGifs
}

type MessagesGetSavedGifs struct {
	// Additional parameters, must be immutable.

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetSavedGifs creates new MessagesGetSavedGifs.
func NewMessagesGetSavedGifs(raw *tg.Client) *MessagesGetSavedGifs {
	q := &MessagesGetSavedGifs{
		acquire: make(chan struct{}, 1),
		raw:     raw,
	}

	return q
}

func (s *MessagesGetSavedGifs) store(v innerMessagesGetSavedGifs) {
	s.last.Store(v)
}

func (s *MessagesGetSavedGifs) load() (innerMessagesGetSavedGifs, bool) {
	v, ok := s.last.Load().(innerMessagesGetSavedGifs)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesSavedGifs must not be mutated.
func (s *MessagesGetSavedGifs) Value() *tg.MessagesSavedGifs {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetSavedGifs) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetSavedGifs) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := lastHash
	result, err := s.raw.MessagesGetSavedGifs(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetSavedGifs: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesSavedGifs:
		hash := variant.Hash

		s.store(innerMessagesGetSavedGifs{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesSavedGifsNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesGetStickers struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesStickers
}

type MessagesGetStickers struct {
	// Additional parameters, must be immutable.
	paramEmoticon string

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesGetStickers creates new MessagesGetStickers.
func NewMessagesGetStickers(raw *tg.Client, paramEmoticon string) *MessagesGetStickers {
	q := &MessagesGetStickers{
		paramEmoticon: paramEmoticon,
		acquire:       make(chan struct{}, 1),
		raw:           raw,
	}

	return q
}

func (s *MessagesGetStickers) store(v innerMessagesGetStickers) {
	s.last.Store(v)
}

func (s *MessagesGetStickers) load() (innerMessagesGetStickers, bool) {
	v, ok := s.last.Load().(innerMessagesGetStickers)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesStickers must not be mutated.
func (s *MessagesGetStickers) Value() *tg.MessagesStickers {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesGetStickers) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesGetStickers) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := &tg.MessagesGetStickersRequest{
		Emoticon: s.paramEmoticon,
		Hash:     lastHash,
	}
	result, err := s.raw.MessagesGetStickers(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesGetStickers: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesStickers:
		hash := variant.Hash

		s.store(innerMessagesGetStickers{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesStickersNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}

type innerMessagesSearchStickerSets struct {
	// Last received hash.
	hash int
	// Last received result.
	value *tg.MessagesFoundStickerSets
}

type MessagesSearchStickerSets struct {
	// Additional parameters, must be immutable.
	paramExcludeFeatured bool
	paramQ               string

	// Helper state.
	last atomic.Value
	// Request state.
	acquire chan struct{}

	// Reference to RPC client to make requests.
	raw *tg.Client
}

// NewMessagesSearchStickerSets creates new MessagesSearchStickerSets.
func NewMessagesSearchStickerSets(raw *tg.Client, paramExcludeFeatured bool, paramQ string) *MessagesSearchStickerSets {
	q := &MessagesSearchStickerSets{
		paramExcludeFeatured: paramExcludeFeatured,
		paramQ:               paramQ,
		acquire:              make(chan struct{}, 1),
		raw:                  raw,
	}

	return q
}

func (s *MessagesSearchStickerSets) store(v innerMessagesSearchStickerSets) {
	s.last.Store(v)
}

func (s *MessagesSearchStickerSets) load() (innerMessagesSearchStickerSets, bool) {
	v, ok := s.last.Load().(innerMessagesSearchStickerSets)
	return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned MessagesFoundStickerSets must not be mutated.
func (s *MessagesSearchStickerSets) Value() *tg.MessagesFoundStickerSets {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *MessagesSearchStickerSets) Hash() int {
	inner, _ := s.load()
	return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *MessagesSearchStickerSets) Fetch(ctx context.Context) (bool, error) {
	// Try acquire.
	select {
	case <-ctx.Done():
		return false, xerrors.Errorf("acquire: %w", ctx.Err())
	case s.acquire <- struct{}{}:
	}
	// Defer release.
	defer func() {
		<-s.acquire
	}()

	lastHash := s.Hash()
	req := &tg.MessagesSearchStickerSetsRequest{
		ExcludeFeatured: s.paramExcludeFeatured,
		Q:               s.paramQ,
		Hash:            lastHash,
	}
	result, err := s.raw.MessagesSearchStickerSets(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute MessagesSearchStickerSets: %w", err)
	}

	switch variant := result.(type) {
	case *tg.MessagesFoundStickerSets:
		hash := variant.Hash

		s.store(innerMessagesSearchStickerSets{
			hash:  hash,
			value: variant,
		})
		return true, nil
	case *tg.MessagesFoundStickerSetsNotModified:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
		return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}
