{{ define "header" }}{{- /*gotype: github.com/gotd/td/telegram/query/internal/cachedgen.Config*/ -}}
// Code generated by itergen, DO NOT EDIT.

package {{ $.Package }}

import (
    "context"
    "sync/atomic"

    "golang.org/x/xerrors"

    "github.com/gotd/td/tg"
)

// No-op definition for keeping imports.
var _ = context.Background()

{{ range $query := $.Queries }}

type inner{{ $query.Name }} struct {
    // Last received hash.
    hash  int
    // Last received result.
	value *tg.{{ $query.ResultName }}
}

type {{ $query.Name }} struct {
    // Additional parameters, must be immutable.
{{- range $param := $query.RequestParams }}
    param{{ $param.OriginalName }} {{ $param.Type }}
{{- end }}

    // Helper state.
    last atomic.Value
    // Request state.
    acquire chan struct{}

    // Reference to RPC client to make requests.
	raw *tg.Client
}

// New{{ $query.Name }} creates new {{ $query.Name }}.
func New{{ $query.Name }}(raw *tg.Client, {{- range $param := $query.RequestParams }}param{{ $param.OriginalName }} {{ $param.Type }},{{- end }}) *{{ $query.Name }} {
    q := &{{ $query.Name }}{
        {{- range $param := $query.RequestParams }}
        param{{ $param.OriginalName }}: param{{ $param.OriginalName }},
        {{- end }}
        acquire: make(chan struct{}, 1),
        raw: raw,
    }

    return q
}

func (s *{{ $query.Name }}) store(v inner{{ $query.Name }}) {
    s.last.Store(v)
}

func (s *{{ $query.Name }}) load() (inner{{ $query.Name }}, bool) {
    v, ok := s.last.Load().(inner{{ $query.Name }})
    return v, ok
}

// Value returns last received result.
// NB: May be nil. Returned {{ $query.ResultName }} must not be mutated.
func (s *{{ $query.Name }}) Value() *tg.{{ $query.ResultName }} {
	inner, _ := s.load()
	return inner.value
}

// Hash returns last received hash.
func (s *{{ $query.Name }}) Hash() int {
    inner, _ := s.load()
    return inner.hash
}

// Fetch updates data if needed. Returns true if data updated.
func (s *{{ $query.Name }}) Fetch(ctx context.Context) (bool, error) {
    // Try acquire.
	select {
    case <-ctx.Done():
        return false, xerrors.Errorf("acquire: %w", ctx.Err())
    case s.acquire <- struct{}{}:
    }
    // Defer release.
    defer func() {
        <-s.acquire
    }()

    lastHash := s.Hash()
    {{ if $query.RequestParams -}}
    req := &tg.{{ $query.RequestName }}{
        {{- range $param := $query.RequestParams }}
        {{ $param.OriginalName }}: s.param{{ $param.OriginalName }},
        {{- end }}
        Hash: lastHash,
    }
    {{- else -}}
    req := lastHash
    {{- end }}
	result, err := s.raw.{{ $query.MethodName }}(ctx, req)
	if err != nil {
		return false, xerrors.Errorf("execute {{ $query.MethodName }}: %w", err)
	}

	switch variant := result.(type) {
    case *tg.{{ $query.ResultName }}:
        {{ if $query.ManualHash -}}
        hash := s.computeHash(variant)
        {{- else -}}
        hash := variant.Hash
        {{- end }}

        s.store(inner{{ $query.Name }}{
            hash: hash,
            value: variant,
        })
        return true, nil
	case *tg.{{ $query.NotModifiedName }}:
		if lastHash == 0 {
			return false, xerrors.Errorf("got unexpected %T result", result)
		}
        return false, nil
	default:
		return false, xerrors.Errorf("unexpected type %T", result)
	}
}
{{ end }}

{{ end }}
