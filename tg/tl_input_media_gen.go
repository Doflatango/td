// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"fmt"

	"github.com/ernado/td/bin"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)

// InputMediaEmpty represents TL type `inputMediaEmpty#9664f57f`.
type InputMediaEmpty struct {
}

// InputMediaEmptyTypeID is TL type id of InputMediaEmpty.
const InputMediaEmptyTypeID = 0x9664f57f

// Encode implements bin.Encoder.
func (i *InputMediaEmpty) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaEmpty#9664f57f as nil")
	}
	b.PutID(InputMediaEmptyTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaEmpty) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaEmpty#9664f57f to nil")
	}
	if err := b.ConsumeID(InputMediaEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaEmpty#9664f57f: %w", err)
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaEmpty) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaEmpty.
var (
	_ bin.Encoder = &InputMediaEmpty{}
	_ bin.Decoder = &InputMediaEmpty{}

	_ InputMediaClass = &InputMediaEmpty{}
)

// InputMediaUploadedPhoto represents TL type `inputMediaUploadedPhoto#1e287d04`.
type InputMediaUploadedPhoto struct {
	// Flags field of InputMediaUploadedPhoto.
	Flags bin.Fields
	// File field of InputMediaUploadedPhoto.
	File InputFileClass
	// Stickers field of InputMediaUploadedPhoto.
	//
	// Use SetStickers and GetStickers helpers.
	Stickers []InputDocumentClass
	// TTLSeconds field of InputMediaUploadedPhoto.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaUploadedPhotoTypeID is TL type id of InputMediaUploadedPhoto.
const InputMediaUploadedPhotoTypeID = 0x1e287d04

// Encode implements bin.Encoder.
func (i *InputMediaUploadedPhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedPhoto#1e287d04 as nil")
	}
	b.PutID(InputMediaUploadedPhotoTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field flags: %w", err)
	}
	if i.File == nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field file is nil")
	}
	if err := i.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field file: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.Stickers))
		for idx, v := range i.Stickers {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field stickers element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field stickers element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(1) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetStickers sets value of Stickers conditional field.
func (i *InputMediaUploadedPhoto) SetStickers(value []InputDocumentClass) {
	i.Flags.Set(0)
	i.Stickers = value
}

// GetStickers returns value of Stickers conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedPhoto) GetStickers() (value []InputDocumentClass, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Stickers, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaUploadedPhoto) SetTTLSeconds(value int) {
	i.Flags.Set(1)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedPhoto) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaUploadedPhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedPhoto#1e287d04 to nil")
	}
	if err := b.ConsumeID(InputMediaUploadedPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field file: %w", err)
		}
		i.File = value
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field stickers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInputDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field stickers: %w", err)
			}
			i.Stickers = append(i.Stickers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaUploadedPhoto) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaUploadedPhoto.
var (
	_ bin.Encoder = &InputMediaUploadedPhoto{}
	_ bin.Decoder = &InputMediaUploadedPhoto{}

	_ InputMediaClass = &InputMediaUploadedPhoto{}
)

// InputMediaPhoto represents TL type `inputMediaPhoto#b3ba0635`.
type InputMediaPhoto struct {
	// Flags field of InputMediaPhoto.
	Flags bin.Fields
	// ID field of InputMediaPhoto.
	ID InputPhotoClass
	// TTLSeconds field of InputMediaPhoto.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaPhotoTypeID is TL type id of InputMediaPhoto.
const InputMediaPhotoTypeID = 0xb3ba0635

// Encode implements bin.Encoder.
func (i *InputMediaPhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhoto#b3ba0635 as nil")
	}
	b.PutID(InputMediaPhotoTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field flags: %w", err)
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field id: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaPhoto) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaPhoto) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaPhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhoto#b3ba0635 to nil")
	}
	if err := b.ConsumeID(InputMediaPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field id: %w", err)
		}
		i.ID = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaPhoto) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPhoto.
var (
	_ bin.Encoder = &InputMediaPhoto{}
	_ bin.Decoder = &InputMediaPhoto{}

	_ InputMediaClass = &InputMediaPhoto{}
)

// InputMediaGeoPoint represents TL type `inputMediaGeoPoint#f9c44144`.
type InputMediaGeoPoint struct {
	// GeoPoint field of InputMediaGeoPoint.
	GeoPoint InputGeoPointClass
}

// InputMediaGeoPointTypeID is TL type id of InputMediaGeoPoint.
const InputMediaGeoPointTypeID = 0xf9c44144

// Encode implements bin.Encoder.
func (i *InputMediaGeoPoint) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoPoint#f9c44144 as nil")
	}
	b.PutID(InputMediaGeoPointTypeID)
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaGeoPoint#f9c44144: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoPoint#f9c44144: field geo_point: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGeoPoint) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoPoint#f9c44144 to nil")
	}
	if err := b.ConsumeID(InputMediaGeoPointTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGeoPoint#f9c44144: %w", err)
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoPoint#f9c44144: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaGeoPoint) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGeoPoint.
var (
	_ bin.Encoder = &InputMediaGeoPoint{}
	_ bin.Decoder = &InputMediaGeoPoint{}

	_ InputMediaClass = &InputMediaGeoPoint{}
)

// InputMediaContact represents TL type `inputMediaContact#f8ab7dfb`.
type InputMediaContact struct {
	// PhoneNumber field of InputMediaContact.
	PhoneNumber string
	// FirstName field of InputMediaContact.
	FirstName string
	// LastName field of InputMediaContact.
	LastName string
	// Vcard field of InputMediaContact.
	Vcard string
}

// InputMediaContactTypeID is TL type id of InputMediaContact.
const InputMediaContactTypeID = 0xf8ab7dfb

// Encode implements bin.Encoder.
func (i *InputMediaContact) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaContact#f8ab7dfb as nil")
	}
	b.PutID(InputMediaContactTypeID)
	b.PutString(i.PhoneNumber)
	b.PutString(i.FirstName)
	b.PutString(i.LastName)
	b.PutString(i.Vcard)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaContact) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaContact#f8ab7dfb to nil")
	}
	if err := b.ConsumeID(InputMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field phone_number: %w", err)
		}
		i.PhoneNumber = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field first_name: %w", err)
		}
		i.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field last_name: %w", err)
		}
		i.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field vcard: %w", err)
		}
		i.Vcard = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaContact) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaContact.
var (
	_ bin.Encoder = &InputMediaContact{}
	_ bin.Decoder = &InputMediaContact{}

	_ InputMediaClass = &InputMediaContact{}
)

// InputMediaUploadedDocument represents TL type `inputMediaUploadedDocument#5b38c6c1`.
type InputMediaUploadedDocument struct {
	// Flags field of InputMediaUploadedDocument.
	Flags bin.Fields
	// NosoundVideo field of InputMediaUploadedDocument.
	NosoundVideo bool
	// ForceFile field of InputMediaUploadedDocument.
	ForceFile bool
	// File field of InputMediaUploadedDocument.
	File InputFileClass
	// Thumb field of InputMediaUploadedDocument.
	//
	// Use SetThumb and GetThumb helpers.
	Thumb InputFileClass
	// MimeType field of InputMediaUploadedDocument.
	MimeType string
	// Attributes field of InputMediaUploadedDocument.
	Attributes []DocumentAttributeClass
	// Stickers field of InputMediaUploadedDocument.
	//
	// Use SetStickers and GetStickers helpers.
	Stickers []InputDocumentClass
	// TTLSeconds field of InputMediaUploadedDocument.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaUploadedDocumentTypeID is TL type id of InputMediaUploadedDocument.
const InputMediaUploadedDocumentTypeID = 0x5b38c6c1

// Encode implements bin.Encoder.
func (i *InputMediaUploadedDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedDocument#5b38c6c1 as nil")
	}
	b.PutID(InputMediaUploadedDocumentTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field flags: %w", err)
	}
	if i.File == nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field file is nil")
	}
	if err := i.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field file: %w", err)
	}
	if i.Flags.Has(2) {
		if i.Thumb == nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field thumb is nil")
		}
		if err := i.Thumb.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field thumb: %w", err)
		}
	}
	b.PutString(i.MimeType)
	b.PutVectorHeader(len(i.Attributes))
	for idx, v := range i.Attributes {
		if v == nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field attributes element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field attributes element with index %d: %w", idx, err)
		}
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.Stickers))
		for idx, v := range i.Stickers {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field stickers element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field stickers element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(1) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetNosoundVideo sets value of NosoundVideo conditional field.
func (i *InputMediaUploadedDocument) SetNosoundVideo(value bool) {
	if value {
		i.Flags.Set(3)
	} else {
		i.Flags.Unset(3)
	}
}

// SetForceFile sets value of ForceFile conditional field.
func (i *InputMediaUploadedDocument) SetForceFile(value bool) {
	if value {
		i.Flags.Set(4)
	} else {
		i.Flags.Unset(4)
	}
}

// SetThumb sets value of Thumb conditional field.
func (i *InputMediaUploadedDocument) SetThumb(value InputFileClass) {
	i.Flags.Set(2)
	i.Thumb = value
}

// GetThumb returns value of Thumb conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetThumb() (value InputFileClass, ok bool) {
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.Thumb, true
}

// SetStickers sets value of Stickers conditional field.
func (i *InputMediaUploadedDocument) SetStickers(value []InputDocumentClass) {
	i.Flags.Set(0)
	i.Stickers = value
}

// GetStickers returns value of Stickers conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetStickers() (value []InputDocumentClass, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Stickers, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaUploadedDocument) SetTTLSeconds(value int) {
	i.Flags.Set(1)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaUploadedDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedDocument#5b38c6c1 to nil")
	}
	if err := b.ConsumeID(InputMediaUploadedDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field flags: %w", err)
		}
	}
	i.NosoundVideo = i.Flags.Has(3)
	i.ForceFile = i.Flags.Has(4)
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field file: %w", err)
		}
		i.File = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field thumb: %w", err)
		}
		i.Thumb = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field mime_type: %w", err)
		}
		i.MimeType = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field attributes: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeDocumentAttribute(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field attributes: %w", err)
			}
			i.Attributes = append(i.Attributes, value)
		}
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field stickers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInputDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field stickers: %w", err)
			}
			i.Stickers = append(i.Stickers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaUploadedDocument) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaUploadedDocument.
var (
	_ bin.Encoder = &InputMediaUploadedDocument{}
	_ bin.Decoder = &InputMediaUploadedDocument{}

	_ InputMediaClass = &InputMediaUploadedDocument{}
)

// InputMediaDocument represents TL type `inputMediaDocument#23ab23d2`.
type InputMediaDocument struct {
	// Flags field of InputMediaDocument.
	Flags bin.Fields
	// ID field of InputMediaDocument.
	ID InputDocumentClass
	// TTLSeconds field of InputMediaDocument.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaDocumentTypeID is TL type id of InputMediaDocument.
const InputMediaDocumentTypeID = 0x23ab23d2

// Encode implements bin.Encoder.
func (i *InputMediaDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocument#23ab23d2 as nil")
	}
	b.PutID(InputMediaDocumentTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocument#23ab23d2: field flags: %w", err)
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaDocument#23ab23d2: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocument#23ab23d2: field id: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaDocument) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocument) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocument#23ab23d2 to nil")
	}
	if err := b.ConsumeID(InputMediaDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDocument#23ab23d2: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#23ab23d2: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#23ab23d2: field id: %w", err)
		}
		i.ID = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#23ab23d2: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaDocument) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDocument.
var (
	_ bin.Encoder = &InputMediaDocument{}
	_ bin.Decoder = &InputMediaDocument{}

	_ InputMediaClass = &InputMediaDocument{}
)

// InputMediaVenue represents TL type `inputMediaVenue#c13d1c11`.
type InputMediaVenue struct {
	// GeoPoint field of InputMediaVenue.
	GeoPoint InputGeoPointClass
	// Title field of InputMediaVenue.
	Title string
	// Address field of InputMediaVenue.
	Address string
	// Provider field of InputMediaVenue.
	Provider string
	// VenueID field of InputMediaVenue.
	VenueID string
	// VenueType field of InputMediaVenue.
	VenueType string
}

// InputMediaVenueTypeID is TL type id of InputMediaVenue.
const InputMediaVenueTypeID = 0xc13d1c11

// Encode implements bin.Encoder.
func (i *InputMediaVenue) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaVenue#c13d1c11 as nil")
	}
	b.PutID(InputMediaVenueTypeID)
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaVenue#c13d1c11: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaVenue#c13d1c11: field geo_point: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Address)
	b.PutString(i.Provider)
	b.PutString(i.VenueID)
	b.PutString(i.VenueType)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaVenue) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaVenue#c13d1c11 to nil")
	}
	if err := b.ConsumeID(InputMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: %w", err)
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field address: %w", err)
		}
		i.Address = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field venue_id: %w", err)
		}
		i.VenueID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field venue_type: %w", err)
		}
		i.VenueType = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaVenue) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaVenue.
var (
	_ bin.Encoder = &InputMediaVenue{}
	_ bin.Decoder = &InputMediaVenue{}

	_ InputMediaClass = &InputMediaVenue{}
)

// InputMediaPhotoExternal represents TL type `inputMediaPhotoExternal#e5bbfe1a`.
type InputMediaPhotoExternal struct {
	// Flags field of InputMediaPhotoExternal.
	Flags bin.Fields
	// URL field of InputMediaPhotoExternal.
	URL string
	// TTLSeconds field of InputMediaPhotoExternal.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaPhotoExternalTypeID is TL type id of InputMediaPhotoExternal.
const InputMediaPhotoExternalTypeID = 0xe5bbfe1a

// Encode implements bin.Encoder.
func (i *InputMediaPhotoExternal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhotoExternal#e5bbfe1a as nil")
	}
	b.PutID(InputMediaPhotoExternalTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhotoExternal#e5bbfe1a: field flags: %w", err)
	}
	b.PutString(i.URL)
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaPhotoExternal) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaPhotoExternal) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaPhotoExternal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhotoExternal#e5bbfe1a to nil")
	}
	if err := b.ConsumeID(InputMediaPhotoExternalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaPhotoExternal) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPhotoExternal.
var (
	_ bin.Encoder = &InputMediaPhotoExternal{}
	_ bin.Decoder = &InputMediaPhotoExternal{}

	_ InputMediaClass = &InputMediaPhotoExternal{}
)

// InputMediaDocumentExternal represents TL type `inputMediaDocumentExternal#fb52dc99`.
type InputMediaDocumentExternal struct {
	// Flags field of InputMediaDocumentExternal.
	Flags bin.Fields
	// URL field of InputMediaDocumentExternal.
	URL string
	// TTLSeconds field of InputMediaDocumentExternal.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaDocumentExternalTypeID is TL type id of InputMediaDocumentExternal.
const InputMediaDocumentExternalTypeID = 0xfb52dc99

// Encode implements bin.Encoder.
func (i *InputMediaDocumentExternal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocumentExternal#fb52dc99 as nil")
	}
	b.PutID(InputMediaDocumentExternalTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocumentExternal#fb52dc99: field flags: %w", err)
	}
	b.PutString(i.URL)
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaDocumentExternal) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocumentExternal) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaDocumentExternal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocumentExternal#fb52dc99 to nil")
	}
	if err := b.ConsumeID(InputMediaDocumentExternalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaDocumentExternal) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDocumentExternal.
var (
	_ bin.Encoder = &InputMediaDocumentExternal{}
	_ bin.Decoder = &InputMediaDocumentExternal{}

	_ InputMediaClass = &InputMediaDocumentExternal{}
)

// InputMediaGame represents TL type `inputMediaGame#d33f43f3`.
type InputMediaGame struct {
	// ID field of InputMediaGame.
	ID InputGameClass
}

// InputMediaGameTypeID is TL type id of InputMediaGame.
const InputMediaGameTypeID = 0xd33f43f3

// Encode implements bin.Encoder.
func (i *InputMediaGame) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGame#d33f43f3 as nil")
	}
	b.PutID(InputMediaGameTypeID)
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaGame#d33f43f3: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGame#d33f43f3: field id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGame) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGame#d33f43f3 to nil")
	}
	if err := b.ConsumeID(InputMediaGameTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGame#d33f43f3: %w", err)
	}
	{
		value, err := DecodeInputGame(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGame#d33f43f3: field id: %w", err)
		}
		i.ID = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaGame) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGame.
var (
	_ bin.Encoder = &InputMediaGame{}
	_ bin.Decoder = &InputMediaGame{}

	_ InputMediaClass = &InputMediaGame{}
)

// InputMediaInvoice represents TL type `inputMediaInvoice#f4e096c3`.
type InputMediaInvoice struct {
	// Flags field of InputMediaInvoice.
	Flags bin.Fields
	// Title field of InputMediaInvoice.
	Title string
	// Description field of InputMediaInvoice.
	Description string
	// Photo field of InputMediaInvoice.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo InputWebDocument
	// Invoice field of InputMediaInvoice.
	Invoice Invoice
	// Payload field of InputMediaInvoice.
	Payload []byte
	// Provider field of InputMediaInvoice.
	Provider string
	// ProviderData field of InputMediaInvoice.
	ProviderData DataJSON
	// StartParam field of InputMediaInvoice.
	StartParam string
}

// InputMediaInvoiceTypeID is TL type id of InputMediaInvoice.
const InputMediaInvoiceTypeID = 0xf4e096c3

// Encode implements bin.Encoder.
func (i *InputMediaInvoice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaInvoice#f4e096c3 as nil")
	}
	b.PutID(InputMediaInvoiceTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field flags: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Description)
	if i.Flags.Has(0) {
		if err := i.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field photo: %w", err)
		}
	}
	if err := i.Invoice.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field invoice: %w", err)
	}
	b.PutBytes(i.Payload)
	b.PutString(i.Provider)
	if err := i.ProviderData.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field provider_data: %w", err)
	}
	b.PutString(i.StartParam)
	return nil
}

// SetPhoto sets value of Photo conditional field.
func (i *InputMediaInvoice) SetPhoto(value InputWebDocument) {
	i.Flags.Set(0)
	i.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (i *InputMediaInvoice) GetPhoto() (value InputWebDocument, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Photo, true
}

// Decode implements bin.Decoder.
func (i *InputMediaInvoice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaInvoice#f4e096c3 to nil")
	}
	if err := b.ConsumeID(InputMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field description: %w", err)
		}
		i.Description = value
	}
	if i.Flags.Has(0) {
		if err := i.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field photo: %w", err)
		}
	}
	{
		if err := i.Invoice.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field invoice: %w", err)
		}
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field payload: %w", err)
		}
		i.Payload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		if err := i.ProviderData.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field provider_data: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field start_param: %w", err)
		}
		i.StartParam = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaInvoice) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaInvoice.
var (
	_ bin.Encoder = &InputMediaInvoice{}
	_ bin.Decoder = &InputMediaInvoice{}

	_ InputMediaClass = &InputMediaInvoice{}
)

// InputMediaGeoLive represents TL type `inputMediaGeoLive#971fa843`.
type InputMediaGeoLive struct {
	// Flags field of InputMediaGeoLive.
	Flags bin.Fields
	// Stopped field of InputMediaGeoLive.
	Stopped bool
	// GeoPoint field of InputMediaGeoLive.
	GeoPoint InputGeoPointClass
	// Heading field of InputMediaGeoLive.
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Period field of InputMediaGeoLive.
	//
	// Use SetPeriod and GetPeriod helpers.
	Period int
	// ProximityNotificationRadius field of InputMediaGeoLive.
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
}

// InputMediaGeoLiveTypeID is TL type id of InputMediaGeoLive.
const InputMediaGeoLiveTypeID = 0x971fa843

// Encode implements bin.Encoder.
func (i *InputMediaGeoLive) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoLive#971fa843 as nil")
	}
	b.PutID(InputMediaGeoLiveTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field flags: %w", err)
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field geo_point: %w", err)
	}
	if i.Flags.Has(2) {
		b.PutInt(i.Heading)
	}
	if i.Flags.Has(1) {
		b.PutInt(i.Period)
	}
	if i.Flags.Has(3) {
		b.PutInt(i.ProximityNotificationRadius)
	}
	return nil
}

// SetStopped sets value of Stopped conditional field.
func (i *InputMediaGeoLive) SetStopped(value bool) {
	if value {
		i.Flags.Set(0)
	} else {
		i.Flags.Unset(0)
	}
}

// SetHeading sets value of Heading conditional field.
func (i *InputMediaGeoLive) SetHeading(value int) {
	i.Flags.Set(2)
	i.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetHeading() (value int, ok bool) {
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.Heading, true
}

// SetPeriod sets value of Period conditional field.
func (i *InputMediaGeoLive) SetPeriod(value int) {
	i.Flags.Set(1)
	i.Period = value
}

// GetPeriod returns value of Period conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetPeriod() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Period, true
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (i *InputMediaGeoLive) SetProximityNotificationRadius(value int) {
	i.Flags.Set(3)
	i.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetProximityNotificationRadius() (value int, ok bool) {
	if !i.Flags.Has(3) {
		return value, false
	}
	return i.ProximityNotificationRadius, true
}

// Decode implements bin.Decoder.
func (i *InputMediaGeoLive) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoLive#971fa843 to nil")
	}
	if err := b.ConsumeID(InputMediaGeoLiveTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field flags: %w", err)
		}
	}
	i.Stopped = i.Flags.Has(0)
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	if i.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field heading: %w", err)
		}
		i.Heading = value
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field period: %w", err)
		}
		i.Period = value
	}
	if i.Flags.Has(3) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field proximity_notification_radius: %w", err)
		}
		i.ProximityNotificationRadius = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaGeoLive) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGeoLive.
var (
	_ bin.Encoder = &InputMediaGeoLive{}
	_ bin.Decoder = &InputMediaGeoLive{}

	_ InputMediaClass = &InputMediaGeoLive{}
)

// InputMediaPoll represents TL type `inputMediaPoll#f94e5f1`.
type InputMediaPoll struct {
	// Flags field of InputMediaPoll.
	Flags bin.Fields
	// Poll field of InputMediaPoll.
	Poll Poll
	// CorrectAnswers field of InputMediaPoll.
	//
	// Use SetCorrectAnswers and GetCorrectAnswers helpers.
	CorrectAnswers [][]byte
	// Solution field of InputMediaPoll.
	//
	// Use SetSolution and GetSolution helpers.
	Solution string
	// SolutionEntities field of InputMediaPoll.
	//
	// Use SetSolutionEntities and GetSolutionEntities helpers.
	SolutionEntities []MessageEntityClass
}

// InputMediaPollTypeID is TL type id of InputMediaPoll.
const InputMediaPollTypeID = 0xf94e5f1

// Encode implements bin.Encoder.
func (i *InputMediaPoll) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPoll#f94e5f1 as nil")
	}
	b.PutID(InputMediaPollTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field flags: %w", err)
	}
	if err := i.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field poll: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.CorrectAnswers))
		for _, v := range i.CorrectAnswers {
			b.PutBytes(v)
		}
	}
	if i.Flags.Has(1) {
		b.PutString(i.Solution)
	}
	if i.Flags.Has(1) {
		b.PutVectorHeader(len(i.SolutionEntities))
		for idx, v := range i.SolutionEntities {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field solution_entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field solution_entities element with index %d: %w", idx, err)
			}
		}
	}
	return nil
}

// SetCorrectAnswers sets value of CorrectAnswers conditional field.
func (i *InputMediaPoll) SetCorrectAnswers(value [][]byte) {
	i.Flags.Set(0)
	i.CorrectAnswers = value
}

// GetCorrectAnswers returns value of CorrectAnswers conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetCorrectAnswers() (value [][]byte, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.CorrectAnswers, true
}

// SetSolution sets value of Solution conditional field.
func (i *InputMediaPoll) SetSolution(value string) {
	i.Flags.Set(1)
	i.Solution = value
}

// GetSolution returns value of Solution conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetSolution() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Solution, true
}

// SetSolutionEntities sets value of SolutionEntities conditional field.
func (i *InputMediaPoll) SetSolutionEntities(value []MessageEntityClass) {
	i.Flags.Set(1)
	i.SolutionEntities = value
}

// GetSolutionEntities returns value of SolutionEntities conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetSolutionEntities() (value []MessageEntityClass, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.SolutionEntities, true
}

// Decode implements bin.Decoder.
func (i *InputMediaPoll) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPoll#f94e5f1 to nil")
	}
	if err := b.ConsumeID(InputMediaPollTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field flags: %w", err)
		}
	}
	{
		if err := i.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field poll: %w", err)
		}
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field correct_answers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field correct_answers: %w", err)
			}
			i.CorrectAnswers = append(i.CorrectAnswers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution: %w", err)
		}
		i.Solution = value
	}
	if i.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution_entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution_entities: %w", err)
			}
			i.SolutionEntities = append(i.SolutionEntities, value)
		}
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaPoll) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPoll.
var (
	_ bin.Encoder = &InputMediaPoll{}
	_ bin.Decoder = &InputMediaPoll{}

	_ InputMediaClass = &InputMediaPoll{}
)

// InputMediaDice represents TL type `inputMediaDice#e66fbf7b`.
type InputMediaDice struct {
	// Emoticon field of InputMediaDice.
	Emoticon string
}

// InputMediaDiceTypeID is TL type id of InputMediaDice.
const InputMediaDiceTypeID = 0xe66fbf7b

// Encode implements bin.Encoder.
func (i *InputMediaDice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDice#e66fbf7b as nil")
	}
	b.PutID(InputMediaDiceTypeID)
	b.PutString(i.Emoticon)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaDice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDice#e66fbf7b to nil")
	}
	if err := b.ConsumeID(InputMediaDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDice#e66fbf7b: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDice#e66fbf7b: field emoticon: %w", err)
		}
		i.Emoticon = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaDice) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDice.
var (
	_ bin.Encoder = &InputMediaDice{}
	_ bin.Decoder = &InputMediaDice{}

	_ InputMediaClass = &InputMediaDice{}
)

// InputMediaClass represents InputMedia generic type.
//
// Example:
//  g, err := DecodeInputMedia(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *InputMediaEmpty: // inputMediaEmpty#9664f57f
//  case *InputMediaUploadedPhoto: // inputMediaUploadedPhoto#1e287d04
//  case *InputMediaPhoto: // inputMediaPhoto#b3ba0635
//  case *InputMediaGeoPoint: // inputMediaGeoPoint#f9c44144
//  case *InputMediaContact: // inputMediaContact#f8ab7dfb
//  case *InputMediaUploadedDocument: // inputMediaUploadedDocument#5b38c6c1
//  case *InputMediaDocument: // inputMediaDocument#23ab23d2
//  case *InputMediaVenue: // inputMediaVenue#c13d1c11
//  case *InputMediaPhotoExternal: // inputMediaPhotoExternal#e5bbfe1a
//  case *InputMediaDocumentExternal: // inputMediaDocumentExternal#fb52dc99
//  case *InputMediaGame: // inputMediaGame#d33f43f3
//  case *InputMediaInvoice: // inputMediaInvoice#f4e096c3
//  case *InputMediaGeoLive: // inputMediaGeoLive#971fa843
//  case *InputMediaPoll: // inputMediaPoll#f94e5f1
//  case *InputMediaDice: // inputMediaDice#e66fbf7b
//  default: panic(v)
//  }
type InputMediaClass interface {
	bin.Encoder
	bin.Decoder
	construct() InputMediaClass
}

// DecodeInputMedia implements binary de-serialization for InputMediaClass.
func DecodeInputMedia(buf *bin.Buffer) (InputMediaClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputMediaEmptyTypeID:
		// Decoding inputMediaEmpty#9664f57f.
		v := InputMediaEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaUploadedPhotoTypeID:
		// Decoding inputMediaUploadedPhoto#1e287d04.
		v := InputMediaUploadedPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPhotoTypeID:
		// Decoding inputMediaPhoto#b3ba0635.
		v := InputMediaPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGeoPointTypeID:
		// Decoding inputMediaGeoPoint#f9c44144.
		v := InputMediaGeoPoint{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaContactTypeID:
		// Decoding inputMediaContact#f8ab7dfb.
		v := InputMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaUploadedDocumentTypeID:
		// Decoding inputMediaUploadedDocument#5b38c6c1.
		v := InputMediaUploadedDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDocumentTypeID:
		// Decoding inputMediaDocument#23ab23d2.
		v := InputMediaDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaVenueTypeID:
		// Decoding inputMediaVenue#c13d1c11.
		v := InputMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPhotoExternalTypeID:
		// Decoding inputMediaPhotoExternal#e5bbfe1a.
		v := InputMediaPhotoExternal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDocumentExternalTypeID:
		// Decoding inputMediaDocumentExternal#fb52dc99.
		v := InputMediaDocumentExternal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGameTypeID:
		// Decoding inputMediaGame#d33f43f3.
		v := InputMediaGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaInvoiceTypeID:
		// Decoding inputMediaInvoice#f4e096c3.
		v := InputMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGeoLiveTypeID:
		// Decoding inputMediaGeoLive#971fa843.
		v := InputMediaGeoLive{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPollTypeID:
		// Decoding inputMediaPoll#f94e5f1.
		v := InputMediaPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDiceTypeID:
		// Decoding inputMediaDice#e66fbf7b.
		v := InputMediaDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMediaClass: %w", bin.NewUnexpectedID(id))
	}
}

// InputMedia boxes the InputMediaClass providing a helper.
type InputMediaBox struct {
	InputMedia InputMediaClass
}

// Decode implements bin.Decoder for InputMediaBox.
func (b *InputMediaBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMediaBox to nil")
	}
	v, err := DecodeInputMedia(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMedia = v
	return nil
}

// Encode implements bin.Encode for InputMediaBox.
func (b *InputMediaBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputMedia == nil {
		return fmt.Errorf("unable to encode InputMediaClass as nil")
	}
	return b.InputMedia.Encode(buf)
}
