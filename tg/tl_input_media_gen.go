// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"fmt"
	"strings"

	"github.com/gotd/td/bin"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)
var _ = strings.Builder{}

// InputMediaEmpty represents TL type `inputMediaEmpty#9664f57f`.
// Empty media content of a message.
//
// See https://core.telegram.org/constructor/inputMediaEmpty for reference.
type InputMediaEmpty struct {
}

// InputMediaEmptyTypeID is TL type id of InputMediaEmpty.
const InputMediaEmptyTypeID = 0x9664f57f

// String implements fmt.Stringer.
func (i *InputMediaEmpty) String() string {
	if i == nil {
		return "InputMediaEmpty(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaEmpty")
	sb.WriteString("{\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaEmpty) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaEmpty#9664f57f as nil")
	}
	b.PutID(InputMediaEmptyTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaEmpty) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaEmpty#9664f57f to nil")
	}
	if err := b.ConsumeID(InputMediaEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaEmpty#9664f57f: %w", err)
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaEmpty) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaEmpty.
var (
	_ bin.Encoder = &InputMediaEmpty{}
	_ bin.Decoder = &InputMediaEmpty{}

	_ InputMediaClass = &InputMediaEmpty{}
)

// InputMediaUploadedPhoto represents TL type `inputMediaUploadedPhoto#1e287d04`.
// Photo
//
// See https://core.telegram.org/constructor/inputMediaUploadedPhoto for reference.
type InputMediaUploadedPhoto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The uploaded file¹
	//
	// Links:
	//  1) https://core.telegram.org/api/files
	File InputFileClass
	// Attached mask stickers
	//
	// Use SetStickers and GetStickers helpers.
	Stickers []InputDocumentClass
	// Time to live in seconds of self-destructing photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaUploadedPhotoTypeID is TL type id of InputMediaUploadedPhoto.
const InputMediaUploadedPhotoTypeID = 0x1e287d04

// String implements fmt.Stringer.
func (i *InputMediaUploadedPhoto) String() string {
	if i == nil {
		return "InputMediaUploadedPhoto(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaUploadedPhoto")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tFile: ")
	sb.WriteString(i.File.String())
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteByte('[')
		for _, v := range i.Stickers {
			sb.WriteString(fmt.Sprint(v))
		}
		sb.WriteByte(']')
	}
	if i.Flags.Has(1) {
		sb.WriteString("\tTTLSeconds: ")
		sb.WriteString(fmt.Sprint(i.TTLSeconds))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaUploadedPhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedPhoto#1e287d04 as nil")
	}
	b.PutID(InputMediaUploadedPhotoTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field flags: %w", err)
	}
	if i.File == nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field file is nil")
	}
	if err := i.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field file: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.Stickers))
		for idx, v := range i.Stickers {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field stickers element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaUploadedPhoto#1e287d04: field stickers element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(1) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetStickers sets value of Stickers conditional field.
func (i *InputMediaUploadedPhoto) SetStickers(value []InputDocumentClass) {
	i.Flags.Set(0)
	i.Stickers = value
}

// GetStickers returns value of Stickers conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedPhoto) GetStickers() (value []InputDocumentClass, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Stickers, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaUploadedPhoto) SetTTLSeconds(value int) {
	i.Flags.Set(1)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedPhoto) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaUploadedPhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedPhoto#1e287d04 to nil")
	}
	if err := b.ConsumeID(InputMediaUploadedPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field file: %w", err)
		}
		i.File = value
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field stickers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInputDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field stickers: %w", err)
			}
			i.Stickers = append(i.Stickers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedPhoto#1e287d04: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaUploadedPhoto) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaUploadedPhoto.
var (
	_ bin.Encoder = &InputMediaUploadedPhoto{}
	_ bin.Decoder = &InputMediaUploadedPhoto{}

	_ InputMediaClass = &InputMediaUploadedPhoto{}
)

// InputMediaPhoto represents TL type `inputMediaPhoto#b3ba0635`.
// Forwarded photo
//
// See https://core.telegram.org/constructor/inputMediaPhoto for reference.
type InputMediaPhoto struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Photo to be forwarded
	ID InputPhotoClass
	// Time to live in seconds of self-destructing photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaPhotoTypeID is TL type id of InputMediaPhoto.
const InputMediaPhotoTypeID = 0xb3ba0635

// String implements fmt.Stringer.
func (i *InputMediaPhoto) String() string {
	if i == nil {
		return "InputMediaPhoto(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaPhoto")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tID: ")
	sb.WriteString(i.ID.String())
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteString("\tTTLSeconds: ")
		sb.WriteString(fmt.Sprint(i.TTLSeconds))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaPhoto) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhoto#b3ba0635 as nil")
	}
	b.PutID(InputMediaPhotoTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field flags: %w", err)
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhoto#b3ba0635: field id: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaPhoto) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaPhoto) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaPhoto) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhoto#b3ba0635 to nil")
	}
	if err := b.ConsumeID(InputMediaPhotoTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputPhoto(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field id: %w", err)
		}
		i.ID = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhoto#b3ba0635: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaPhoto) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPhoto.
var (
	_ bin.Encoder = &InputMediaPhoto{}
	_ bin.Decoder = &InputMediaPhoto{}

	_ InputMediaClass = &InputMediaPhoto{}
)

// InputMediaGeoPoint represents TL type `inputMediaGeoPoint#f9c44144`.
// Map.
//
// See https://core.telegram.org/constructor/inputMediaGeoPoint for reference.
type InputMediaGeoPoint struct {
	// GeoPoint
	GeoPoint InputGeoPointClass
}

// InputMediaGeoPointTypeID is TL type id of InputMediaGeoPoint.
const InputMediaGeoPointTypeID = 0xf9c44144

// String implements fmt.Stringer.
func (i *InputMediaGeoPoint) String() string {
	if i == nil {
		return "InputMediaGeoPoint(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaGeoPoint")
	sb.WriteString("{\n")
	sb.WriteString("\tGeoPoint: ")
	sb.WriteString(i.GeoPoint.String())
	sb.WriteString(",\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaGeoPoint) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoPoint#f9c44144 as nil")
	}
	b.PutID(InputMediaGeoPointTypeID)
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaGeoPoint#f9c44144: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoPoint#f9c44144: field geo_point: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGeoPoint) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoPoint#f9c44144 to nil")
	}
	if err := b.ConsumeID(InputMediaGeoPointTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGeoPoint#f9c44144: %w", err)
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoPoint#f9c44144: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaGeoPoint) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGeoPoint.
var (
	_ bin.Encoder = &InputMediaGeoPoint{}
	_ bin.Decoder = &InputMediaGeoPoint{}

	_ InputMediaClass = &InputMediaGeoPoint{}
)

// InputMediaContact represents TL type `inputMediaContact#f8ab7dfb`.
// Phonebook contact
//
// See https://core.telegram.org/constructor/inputMediaContact for reference.
type InputMediaContact struct {
	// Phone number
	PhoneNumber string
	// Contact's first name
	FirstName string
	// Contact's last name
	LastName string
	// Contact vcard
	Vcard string
}

// InputMediaContactTypeID is TL type id of InputMediaContact.
const InputMediaContactTypeID = 0xf8ab7dfb

// String implements fmt.Stringer.
func (i *InputMediaContact) String() string {
	if i == nil {
		return "InputMediaContact(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaContact")
	sb.WriteString("{\n")
	sb.WriteString("\tPhoneNumber: ")
	sb.WriteString(fmt.Sprint(i.PhoneNumber))
	sb.WriteString(",\n")
	sb.WriteString("\tFirstName: ")
	sb.WriteString(fmt.Sprint(i.FirstName))
	sb.WriteString(",\n")
	sb.WriteString("\tLastName: ")
	sb.WriteString(fmt.Sprint(i.LastName))
	sb.WriteString(",\n")
	sb.WriteString("\tVcard: ")
	sb.WriteString(fmt.Sprint(i.Vcard))
	sb.WriteString(",\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaContact) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaContact#f8ab7dfb as nil")
	}
	b.PutID(InputMediaContactTypeID)
	b.PutString(i.PhoneNumber)
	b.PutString(i.FirstName)
	b.PutString(i.LastName)
	b.PutString(i.Vcard)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaContact) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaContact#f8ab7dfb to nil")
	}
	if err := b.ConsumeID(InputMediaContactTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field phone_number: %w", err)
		}
		i.PhoneNumber = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field first_name: %w", err)
		}
		i.FirstName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field last_name: %w", err)
		}
		i.LastName = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaContact#f8ab7dfb: field vcard: %w", err)
		}
		i.Vcard = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaContact) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaContact.
var (
	_ bin.Encoder = &InputMediaContact{}
	_ bin.Decoder = &InputMediaContact{}

	_ InputMediaClass = &InputMediaContact{}
)

// InputMediaUploadedDocument represents TL type `inputMediaUploadedDocument#5b38c6c1`.
// New document
//
// See https://core.telegram.org/constructor/inputMediaUploadedDocument for reference.
type InputMediaUploadedDocument struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether the specified document is a video file with no audio tracks (a GIF animation (even as MPEG4), for example)
	NosoundVideo bool
	// Force the media file to be uploaded as document
	ForceFile bool
	// The uploaded file¹
	//
	// Links:
	//  1) https://core.telegram.org/api/files
	File InputFileClass
	// Thumbnail of the document, uploaded as for the file
	//
	// Use SetThumb and GetThumb helpers.
	Thumb InputFileClass
	// MIME type of document
	MimeType string
	// Attributes that specify the type of the document (video, audio, voice, sticker, etc.)
	Attributes []DocumentAttributeClass
	// Attached stickers
	//
	// Use SetStickers and GetStickers helpers.
	Stickers []InputDocumentClass
	// Time to live in seconds of self-destructing document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaUploadedDocumentTypeID is TL type id of InputMediaUploadedDocument.
const InputMediaUploadedDocumentTypeID = 0x5b38c6c1

// String implements fmt.Stringer.
func (i *InputMediaUploadedDocument) String() string {
	if i == nil {
		return "InputMediaUploadedDocument(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaUploadedDocument")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tFile: ")
	sb.WriteString(i.File.String())
	sb.WriteString(",\n")
	if i.Flags.Has(2) {
		sb.WriteString("\tThumb: ")
		sb.WriteString(i.Thumb.String())
		sb.WriteString(",\n")
	}
	sb.WriteString("\tMimeType: ")
	sb.WriteString(fmt.Sprint(i.MimeType))
	sb.WriteString(",\n")
	sb.WriteByte('[')
	for _, v := range i.Attributes {
		sb.WriteString(fmt.Sprint(v))
	}
	sb.WriteByte(']')
	if i.Flags.Has(0) {
		sb.WriteByte('[')
		for _, v := range i.Stickers {
			sb.WriteString(fmt.Sprint(v))
		}
		sb.WriteByte(']')
	}
	if i.Flags.Has(1) {
		sb.WriteString("\tTTLSeconds: ")
		sb.WriteString(fmt.Sprint(i.TTLSeconds))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaUploadedDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaUploadedDocument#5b38c6c1 as nil")
	}
	b.PutID(InputMediaUploadedDocumentTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field flags: %w", err)
	}
	if i.File == nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field file is nil")
	}
	if err := i.File.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field file: %w", err)
	}
	if i.Flags.Has(2) {
		if i.Thumb == nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field thumb is nil")
		}
		if err := i.Thumb.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field thumb: %w", err)
		}
	}
	b.PutString(i.MimeType)
	b.PutVectorHeader(len(i.Attributes))
	for idx, v := range i.Attributes {
		if v == nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field attributes element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field attributes element with index %d: %w", idx, err)
		}
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.Stickers))
		for idx, v := range i.Stickers {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field stickers element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaUploadedDocument#5b38c6c1: field stickers element with index %d: %w", idx, err)
			}
		}
	}
	if i.Flags.Has(1) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetNosoundVideo sets value of NosoundVideo conditional field.
func (i *InputMediaUploadedDocument) SetNosoundVideo(value bool) {
	if value {
		i.Flags.Set(3)
		i.NosoundVideo = true
	} else {
		i.Flags.Unset(3)
		i.NosoundVideo = false
	}
}

// SetForceFile sets value of ForceFile conditional field.
func (i *InputMediaUploadedDocument) SetForceFile(value bool) {
	if value {
		i.Flags.Set(4)
		i.ForceFile = true
	} else {
		i.Flags.Unset(4)
		i.ForceFile = false
	}
}

// SetThumb sets value of Thumb conditional field.
func (i *InputMediaUploadedDocument) SetThumb(value InputFileClass) {
	i.Flags.Set(2)
	i.Thumb = value
}

// GetThumb returns value of Thumb conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetThumb() (value InputFileClass, ok bool) {
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.Thumb, true
}

// SetStickers sets value of Stickers conditional field.
func (i *InputMediaUploadedDocument) SetStickers(value []InputDocumentClass) {
	i.Flags.Set(0)
	i.Stickers = value
}

// GetStickers returns value of Stickers conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetStickers() (value []InputDocumentClass, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Stickers, true
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaUploadedDocument) SetTTLSeconds(value int) {
	i.Flags.Set(1)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaUploadedDocument) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaUploadedDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaUploadedDocument#5b38c6c1 to nil")
	}
	if err := b.ConsumeID(InputMediaUploadedDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field flags: %w", err)
		}
	}
	i.NosoundVideo = i.Flags.Has(3)
	i.ForceFile = i.Flags.Has(4)
	{
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field file: %w", err)
		}
		i.File = value
	}
	if i.Flags.Has(2) {
		value, err := DecodeInputFile(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field thumb: %w", err)
		}
		i.Thumb = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field mime_type: %w", err)
		}
		i.MimeType = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field attributes: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeDocumentAttribute(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field attributes: %w", err)
			}
			i.Attributes = append(i.Attributes, value)
		}
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field stickers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeInputDocument(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field stickers: %w", err)
			}
			i.Stickers = append(i.Stickers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaUploadedDocument#5b38c6c1: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaUploadedDocument) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaUploadedDocument.
var (
	_ bin.Encoder = &InputMediaUploadedDocument{}
	_ bin.Decoder = &InputMediaUploadedDocument{}

	_ InputMediaClass = &InputMediaUploadedDocument{}
)

// InputMediaDocument represents TL type `inputMediaDocument#33473058`.
// Forwarded document
//
// See https://core.telegram.org/constructor/inputMediaDocument for reference.
type InputMediaDocument struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The document to be forwarded.
	ID InputDocumentClass
	// Time to live of self-destructing document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
	// Query field of InputMediaDocument.
	//
	// Use SetQuery and GetQuery helpers.
	Query string
}

// InputMediaDocumentTypeID is TL type id of InputMediaDocument.
const InputMediaDocumentTypeID = 0x33473058

// String implements fmt.Stringer.
func (i *InputMediaDocument) String() string {
	if i == nil {
		return "InputMediaDocument(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaDocument")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tID: ")
	sb.WriteString(i.ID.String())
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteString("\tTTLSeconds: ")
		sb.WriteString(fmt.Sprint(i.TTLSeconds))
		sb.WriteString(",\n")
	}
	if i.Flags.Has(1) {
		sb.WriteString("\tQuery: ")
		sb.WriteString(fmt.Sprint(i.Query))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaDocument) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocument#33473058 as nil")
	}
	b.PutID(InputMediaDocumentTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocument#33473058: field flags: %w", err)
	}
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaDocument#33473058: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocument#33473058: field id: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	if i.Flags.Has(1) {
		b.PutString(i.Query)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaDocument) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocument) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// SetQuery sets value of Query conditional field.
func (i *InputMediaDocument) SetQuery(value string) {
	i.Flags.Set(1)
	i.Query = value
}

// GetQuery returns value of Query conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocument) GetQuery() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Query, true
}

// Decode implements bin.Decoder.
func (i *InputMediaDocument) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocument#33473058 to nil")
	}
	if err := b.ConsumeID(InputMediaDocumentTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDocument#33473058: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field flags: %w", err)
		}
	}
	{
		value, err := DecodeInputDocument(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field id: %w", err)
		}
		i.ID = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocument#33473058: field query: %w", err)
		}
		i.Query = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaDocument) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDocument.
var (
	_ bin.Encoder = &InputMediaDocument{}
	_ bin.Decoder = &InputMediaDocument{}

	_ InputMediaClass = &InputMediaDocument{}
)

// InputMediaVenue represents TL type `inputMediaVenue#c13d1c11`.
// Can be used to send a venue geolocation.
//
// See https://core.telegram.org/constructor/inputMediaVenue for reference.
type InputMediaVenue struct {
	// Geolocation
	GeoPoint InputGeoPointClass
	// Venue name
	Title string
	// Physical address of the venue
	Address string
	// Venue provider: currently only "foursquare" needs to be supported
	Provider string
	// Venue ID in the provider's database
	VenueID string
	// Venue type in the provider's database
	VenueType string
}

// InputMediaVenueTypeID is TL type id of InputMediaVenue.
const InputMediaVenueTypeID = 0xc13d1c11

// String implements fmt.Stringer.
func (i *InputMediaVenue) String() string {
	if i == nil {
		return "InputMediaVenue(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaVenue")
	sb.WriteString("{\n")
	sb.WriteString("\tGeoPoint: ")
	sb.WriteString(i.GeoPoint.String())
	sb.WriteString(",\n")
	sb.WriteString("\tTitle: ")
	sb.WriteString(fmt.Sprint(i.Title))
	sb.WriteString(",\n")
	sb.WriteString("\tAddress: ")
	sb.WriteString(fmt.Sprint(i.Address))
	sb.WriteString(",\n")
	sb.WriteString("\tProvider: ")
	sb.WriteString(fmt.Sprint(i.Provider))
	sb.WriteString(",\n")
	sb.WriteString("\tVenueID: ")
	sb.WriteString(fmt.Sprint(i.VenueID))
	sb.WriteString(",\n")
	sb.WriteString("\tVenueType: ")
	sb.WriteString(fmt.Sprint(i.VenueType))
	sb.WriteString(",\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaVenue) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaVenue#c13d1c11 as nil")
	}
	b.PutID(InputMediaVenueTypeID)
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaVenue#c13d1c11: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaVenue#c13d1c11: field geo_point: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Address)
	b.PutString(i.Provider)
	b.PutString(i.VenueID)
	b.PutString(i.VenueType)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaVenue) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaVenue#c13d1c11 to nil")
	}
	if err := b.ConsumeID(InputMediaVenueTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: %w", err)
	}
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field address: %w", err)
		}
		i.Address = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field venue_id: %w", err)
		}
		i.VenueID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaVenue#c13d1c11: field venue_type: %w", err)
		}
		i.VenueType = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaVenue) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaVenue.
var (
	_ bin.Encoder = &InputMediaVenue{}
	_ bin.Decoder = &InputMediaVenue{}

	_ InputMediaClass = &InputMediaVenue{}
)

// InputMediaPhotoExternal represents TL type `inputMediaPhotoExternal#e5bbfe1a`.
// New photo that will be uploaded by the server using the specified URL
//
// See https://core.telegram.org/constructor/inputMediaPhotoExternal for reference.
type InputMediaPhotoExternal struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// URL of the photo
	URL string
	// Self-destruct time to live of photo
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaPhotoExternalTypeID is TL type id of InputMediaPhotoExternal.
const InputMediaPhotoExternalTypeID = 0xe5bbfe1a

// String implements fmt.Stringer.
func (i *InputMediaPhotoExternal) String() string {
	if i == nil {
		return "InputMediaPhotoExternal(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaPhotoExternal")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tURL: ")
	sb.WriteString(fmt.Sprint(i.URL))
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteString("\tTTLSeconds: ")
		sb.WriteString(fmt.Sprint(i.TTLSeconds))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaPhotoExternal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPhotoExternal#e5bbfe1a as nil")
	}
	b.PutID(InputMediaPhotoExternalTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPhotoExternal#e5bbfe1a: field flags: %w", err)
	}
	b.PutString(i.URL)
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaPhotoExternal) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaPhotoExternal) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaPhotoExternal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPhotoExternal#e5bbfe1a to nil")
	}
	if err := b.ConsumeID(InputMediaPhotoExternalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPhotoExternal#e5bbfe1a: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaPhotoExternal) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPhotoExternal.
var (
	_ bin.Encoder = &InputMediaPhotoExternal{}
	_ bin.Decoder = &InputMediaPhotoExternal{}

	_ InputMediaClass = &InputMediaPhotoExternal{}
)

// InputMediaDocumentExternal represents TL type `inputMediaDocumentExternal#fb52dc99`.
// Document that will be downloaded by the telegram servers
//
// See https://core.telegram.org/constructor/inputMediaDocumentExternal for reference.
type InputMediaDocumentExternal struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// URL of the document
	URL string
	// Self-destruct time to live of document
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// InputMediaDocumentExternalTypeID is TL type id of InputMediaDocumentExternal.
const InputMediaDocumentExternalTypeID = 0xfb52dc99

// String implements fmt.Stringer.
func (i *InputMediaDocumentExternal) String() string {
	if i == nil {
		return "InputMediaDocumentExternal(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaDocumentExternal")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tURL: ")
	sb.WriteString(fmt.Sprint(i.URL))
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteString("\tTTLSeconds: ")
		sb.WriteString(fmt.Sprint(i.TTLSeconds))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaDocumentExternal) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDocumentExternal#fb52dc99 as nil")
	}
	b.PutID(InputMediaDocumentExternalTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaDocumentExternal#fb52dc99: field flags: %w", err)
	}
	b.PutString(i.URL)
	if i.Flags.Has(0) {
		b.PutInt(i.TTLSeconds)
	}
	return nil
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (i *InputMediaDocumentExternal) SetTTLSeconds(value int) {
	i.Flags.Set(0)
	i.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (i *InputMediaDocumentExternal) GetTTLSeconds() (value int, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (i *InputMediaDocumentExternal) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDocumentExternal#fb52dc99 to nil")
	}
	if err := b.ConsumeID(InputMediaDocumentExternalTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field url: %w", err)
		}
		i.URL = value
	}
	if i.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDocumentExternal#fb52dc99: field ttl_seconds: %w", err)
		}
		i.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaDocumentExternal) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDocumentExternal.
var (
	_ bin.Encoder = &InputMediaDocumentExternal{}
	_ bin.Decoder = &InputMediaDocumentExternal{}

	_ InputMediaClass = &InputMediaDocumentExternal{}
)

// InputMediaGame represents TL type `inputMediaGame#d33f43f3`.
// A game
//
// See https://core.telegram.org/constructor/inputMediaGame for reference.
type InputMediaGame struct {
	// The game to forward
	ID InputGameClass
}

// InputMediaGameTypeID is TL type id of InputMediaGame.
const InputMediaGameTypeID = 0xd33f43f3

// String implements fmt.Stringer.
func (i *InputMediaGame) String() string {
	if i == nil {
		return "InputMediaGame(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaGame")
	sb.WriteString("{\n")
	sb.WriteString("\tID: ")
	sb.WriteString(i.ID.String())
	sb.WriteString(",\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaGame) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGame#d33f43f3 as nil")
	}
	b.PutID(InputMediaGameTypeID)
	if i.ID == nil {
		return fmt.Errorf("unable to encode inputMediaGame#d33f43f3: field id is nil")
	}
	if err := i.ID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGame#d33f43f3: field id: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaGame) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGame#d33f43f3 to nil")
	}
	if err := b.ConsumeID(InputMediaGameTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGame#d33f43f3: %w", err)
	}
	{
		value, err := DecodeInputGame(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGame#d33f43f3: field id: %w", err)
		}
		i.ID = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaGame) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGame.
var (
	_ bin.Encoder = &InputMediaGame{}
	_ bin.Decoder = &InputMediaGame{}

	_ InputMediaClass = &InputMediaGame{}
)

// InputMediaInvoice represents TL type `inputMediaInvoice#f4e096c3`.
// Generated invoice of a bot payment¹
//
// Links:
//  1) https://core.telegram.org/bots/payments
//
// See https://core.telegram.org/constructor/inputMediaInvoice for reference.
type InputMediaInvoice struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Product name, 1-32 characters
	Title string
	// Product description, 1-255 characters
	Description string
	// URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for.
	//
	// Use SetPhoto and GetPhoto helpers.
	Photo InputWebDocument
	// The actual invoice
	Invoice Invoice
	// Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes.
	Payload []byte
	// Payments provider token, obtained via Botfather¹
	//
	// Links:
	//  1) https://t.me/botfather
	Provider string
	// JSON-encoded data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider.
	ProviderData DataJSON
	// Start parameter
	StartParam string
}

// InputMediaInvoiceTypeID is TL type id of InputMediaInvoice.
const InputMediaInvoiceTypeID = 0xf4e096c3

// String implements fmt.Stringer.
func (i *InputMediaInvoice) String() string {
	if i == nil {
		return "InputMediaInvoice(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaInvoice")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tTitle: ")
	sb.WriteString(fmt.Sprint(i.Title))
	sb.WriteString(",\n")
	sb.WriteString("\tDescription: ")
	sb.WriteString(fmt.Sprint(i.Description))
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteString("\tPhoto: ")
		sb.WriteString(i.Photo.String())
		sb.WriteString(",\n")
	}
	sb.WriteString("\tInvoice: ")
	sb.WriteString(i.Invoice.String())
	sb.WriteString(",\n")
	sb.WriteString("\tPayload: ")
	sb.WriteString(fmt.Sprint(i.Payload))
	sb.WriteString(",\n")
	sb.WriteString("\tProvider: ")
	sb.WriteString(fmt.Sprint(i.Provider))
	sb.WriteString(",\n")
	sb.WriteString("\tProviderData: ")
	sb.WriteString(i.ProviderData.String())
	sb.WriteString(",\n")
	sb.WriteString("\tStartParam: ")
	sb.WriteString(fmt.Sprint(i.StartParam))
	sb.WriteString(",\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaInvoice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaInvoice#f4e096c3 as nil")
	}
	b.PutID(InputMediaInvoiceTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field flags: %w", err)
	}
	b.PutString(i.Title)
	b.PutString(i.Description)
	if i.Flags.Has(0) {
		if err := i.Photo.Encode(b); err != nil {
			return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field photo: %w", err)
		}
	}
	if err := i.Invoice.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field invoice: %w", err)
	}
	b.PutBytes(i.Payload)
	b.PutString(i.Provider)
	if err := i.ProviderData.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaInvoice#f4e096c3: field provider_data: %w", err)
	}
	b.PutString(i.StartParam)
	return nil
}

// SetPhoto sets value of Photo conditional field.
func (i *InputMediaInvoice) SetPhoto(value InputWebDocument) {
	i.Flags.Set(0)
	i.Photo = value
}

// GetPhoto returns value of Photo conditional field and
// boolean which is true if field was set.
func (i *InputMediaInvoice) GetPhoto() (value InputWebDocument, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.Photo, true
}

// Decode implements bin.Decoder.
func (i *InputMediaInvoice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaInvoice#f4e096c3 to nil")
	}
	if err := b.ConsumeID(InputMediaInvoiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field flags: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field title: %w", err)
		}
		i.Title = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field description: %w", err)
		}
		i.Description = value
	}
	if i.Flags.Has(0) {
		if err := i.Photo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field photo: %w", err)
		}
	}
	{
		if err := i.Invoice.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field invoice: %w", err)
		}
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field payload: %w", err)
		}
		i.Payload = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field provider: %w", err)
		}
		i.Provider = value
	}
	{
		if err := i.ProviderData.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field provider_data: %w", err)
		}
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaInvoice#f4e096c3: field start_param: %w", err)
		}
		i.StartParam = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaInvoice) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaInvoice.
var (
	_ bin.Encoder = &InputMediaInvoice{}
	_ bin.Decoder = &InputMediaInvoice{}

	_ InputMediaClass = &InputMediaInvoice{}
)

// InputMediaGeoLive represents TL type `inputMediaGeoLive#971fa843`.
// Live geolocation¹
//
// Links:
//  1) https://core.telegram.org/api/live-location
//
// See https://core.telegram.org/constructor/inputMediaGeoLive for reference.
type InputMediaGeoLive struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// Whether sending of the geolocation was stopped
	Stopped bool
	// Current geolocation
	GeoPoint InputGeoPointClass
	// For live locations¹, a direction in which the location moves, in degrees; 1-360.
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetHeading and GetHeading helpers.
	Heading int
	// Validity period of the current location
	//
	// Use SetPeriod and GetPeriod helpers.
	Period int
	// For live locations¹, a maximum distance to another chat member for proximity alerts, in meters (0-100000)
	//
	// Links:
	//  1) https://core.telegram.org/api/live-location
	//
	// Use SetProximityNotificationRadius and GetProximityNotificationRadius helpers.
	ProximityNotificationRadius int
}

// InputMediaGeoLiveTypeID is TL type id of InputMediaGeoLive.
const InputMediaGeoLiveTypeID = 0x971fa843

// String implements fmt.Stringer.
func (i *InputMediaGeoLive) String() string {
	if i == nil {
		return "InputMediaGeoLive(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaGeoLive")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tGeoPoint: ")
	sb.WriteString(i.GeoPoint.String())
	sb.WriteString(",\n")
	if i.Flags.Has(2) {
		sb.WriteString("\tHeading: ")
		sb.WriteString(fmt.Sprint(i.Heading))
		sb.WriteString(",\n")
	}
	if i.Flags.Has(1) {
		sb.WriteString("\tPeriod: ")
		sb.WriteString(fmt.Sprint(i.Period))
		sb.WriteString(",\n")
	}
	if i.Flags.Has(3) {
		sb.WriteString("\tProximityNotificationRadius: ")
		sb.WriteString(fmt.Sprint(i.ProximityNotificationRadius))
		sb.WriteString(",\n")
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaGeoLive) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaGeoLive#971fa843 as nil")
	}
	b.PutID(InputMediaGeoLiveTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field flags: %w", err)
	}
	if i.GeoPoint == nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field geo_point is nil")
	}
	if err := i.GeoPoint.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaGeoLive#971fa843: field geo_point: %w", err)
	}
	if i.Flags.Has(2) {
		b.PutInt(i.Heading)
	}
	if i.Flags.Has(1) {
		b.PutInt(i.Period)
	}
	if i.Flags.Has(3) {
		b.PutInt(i.ProximityNotificationRadius)
	}
	return nil
}

// SetStopped sets value of Stopped conditional field.
func (i *InputMediaGeoLive) SetStopped(value bool) {
	if value {
		i.Flags.Set(0)
		i.Stopped = true
	} else {
		i.Flags.Unset(0)
		i.Stopped = false
	}
}

// SetHeading sets value of Heading conditional field.
func (i *InputMediaGeoLive) SetHeading(value int) {
	i.Flags.Set(2)
	i.Heading = value
}

// GetHeading returns value of Heading conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetHeading() (value int, ok bool) {
	if !i.Flags.Has(2) {
		return value, false
	}
	return i.Heading, true
}

// SetPeriod sets value of Period conditional field.
func (i *InputMediaGeoLive) SetPeriod(value int) {
	i.Flags.Set(1)
	i.Period = value
}

// GetPeriod returns value of Period conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetPeriod() (value int, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Period, true
}

// SetProximityNotificationRadius sets value of ProximityNotificationRadius conditional field.
func (i *InputMediaGeoLive) SetProximityNotificationRadius(value int) {
	i.Flags.Set(3)
	i.ProximityNotificationRadius = value
}

// GetProximityNotificationRadius returns value of ProximityNotificationRadius conditional field and
// boolean which is true if field was set.
func (i *InputMediaGeoLive) GetProximityNotificationRadius() (value int, ok bool) {
	if !i.Flags.Has(3) {
		return value, false
	}
	return i.ProximityNotificationRadius, true
}

// Decode implements bin.Decoder.
func (i *InputMediaGeoLive) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaGeoLive#971fa843 to nil")
	}
	if err := b.ConsumeID(InputMediaGeoLiveTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field flags: %w", err)
		}
	}
	i.Stopped = i.Flags.Has(0)
	{
		value, err := DecodeInputGeoPoint(b)
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field geo_point: %w", err)
		}
		i.GeoPoint = value
	}
	if i.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field heading: %w", err)
		}
		i.Heading = value
	}
	if i.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field period: %w", err)
		}
		i.Period = value
	}
	if i.Flags.Has(3) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaGeoLive#971fa843: field proximity_notification_radius: %w", err)
		}
		i.ProximityNotificationRadius = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaGeoLive) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaGeoLive.
var (
	_ bin.Encoder = &InputMediaGeoLive{}
	_ bin.Decoder = &InputMediaGeoLive{}

	_ InputMediaClass = &InputMediaGeoLive{}
)

// InputMediaPoll represents TL type `inputMediaPoll#f94e5f1`.
// A poll
//
// See https://core.telegram.org/constructor/inputMediaPoll for reference.
type InputMediaPoll struct {
	// Flags, see TL conditional fields¹
	//
	// Links:
	//  1) https://core.telegram.org/mtproto/TL-combinators#conditional-fields
	Flags bin.Fields
	// The poll to send
	Poll Poll
	// Correct answer IDs (for quiz polls)
	//
	// Use SetCorrectAnswers and GetCorrectAnswers helpers.
	CorrectAnswers [][]byte
	// Explanation of quiz solution
	//
	// Use SetSolution and GetSolution helpers.
	Solution string
	// Message entities for styled text¹
	//
	// Links:
	//  1) https://core.telegram.org/api/entities
	//
	// Use SetSolutionEntities and GetSolutionEntities helpers.
	SolutionEntities []MessageEntityClass
}

// InputMediaPollTypeID is TL type id of InputMediaPoll.
const InputMediaPollTypeID = 0xf94e5f1

// String implements fmt.Stringer.
func (i *InputMediaPoll) String() string {
	if i == nil {
		return "InputMediaPoll(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaPoll")
	sb.WriteString("{\n")
	sb.WriteString("\tFlags: ")
	sb.WriteString(i.Flags.String())
	sb.WriteString(",\n")
	sb.WriteString("\tPoll: ")
	sb.WriteString(i.Poll.String())
	sb.WriteString(",\n")
	if i.Flags.Has(0) {
		sb.WriteByte('[')
		for _, v := range i.CorrectAnswers {
			sb.WriteString(fmt.Sprint(v))
		}
		sb.WriteByte(']')
	}
	if i.Flags.Has(1) {
		sb.WriteString("\tSolution: ")
		sb.WriteString(fmt.Sprint(i.Solution))
		sb.WriteString(",\n")
	}
	if i.Flags.Has(1) {
		sb.WriteByte('[')
		for _, v := range i.SolutionEntities {
			sb.WriteString(fmt.Sprint(v))
		}
		sb.WriteByte(']')
	}
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaPoll) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaPoll#f94e5f1 as nil")
	}
	b.PutID(InputMediaPollTypeID)
	if err := i.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field flags: %w", err)
	}
	if err := i.Poll.Encode(b); err != nil {
		return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field poll: %w", err)
	}
	if i.Flags.Has(0) {
		b.PutVectorHeader(len(i.CorrectAnswers))
		for _, v := range i.CorrectAnswers {
			b.PutBytes(v)
		}
	}
	if i.Flags.Has(1) {
		b.PutString(i.Solution)
	}
	if i.Flags.Has(1) {
		b.PutVectorHeader(len(i.SolutionEntities))
		for idx, v := range i.SolutionEntities {
			if v == nil {
				return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field solution_entities element with index %d is nil", idx)
			}
			if err := v.Encode(b); err != nil {
				return fmt.Errorf("unable to encode inputMediaPoll#f94e5f1: field solution_entities element with index %d: %w", idx, err)
			}
		}
	}
	return nil
}

// SetCorrectAnswers sets value of CorrectAnswers conditional field.
func (i *InputMediaPoll) SetCorrectAnswers(value [][]byte) {
	i.Flags.Set(0)
	i.CorrectAnswers = value
}

// GetCorrectAnswers returns value of CorrectAnswers conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetCorrectAnswers() (value [][]byte, ok bool) {
	if !i.Flags.Has(0) {
		return value, false
	}
	return i.CorrectAnswers, true
}

// SetSolution sets value of Solution conditional field.
func (i *InputMediaPoll) SetSolution(value string) {
	i.Flags.Set(1)
	i.Solution = value
}

// GetSolution returns value of Solution conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetSolution() (value string, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.Solution, true
}

// SetSolutionEntities sets value of SolutionEntities conditional field.
func (i *InputMediaPoll) SetSolutionEntities(value []MessageEntityClass) {
	i.Flags.Set(1)
	i.SolutionEntities = value
}

// GetSolutionEntities returns value of SolutionEntities conditional field and
// boolean which is true if field was set.
func (i *InputMediaPoll) GetSolutionEntities() (value []MessageEntityClass, ok bool) {
	if !i.Flags.Has(1) {
		return value, false
	}
	return i.SolutionEntities, true
}

// Decode implements bin.Decoder.
func (i *InputMediaPoll) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaPoll#f94e5f1 to nil")
	}
	if err := b.ConsumeID(InputMediaPollTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: %w", err)
	}
	{
		if err := i.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field flags: %w", err)
		}
	}
	{
		if err := i.Poll.Decode(b); err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field poll: %w", err)
		}
	}
	if i.Flags.Has(0) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field correct_answers: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field correct_answers: %w", err)
			}
			i.CorrectAnswers = append(i.CorrectAnswers, value)
		}
	}
	if i.Flags.Has(1) {
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution: %w", err)
		}
		i.Solution = value
	}
	if i.Flags.Has(1) {
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution_entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessageEntity(b)
			if err != nil {
				return fmt.Errorf("unable to decode inputMediaPoll#f94e5f1: field solution_entities: %w", err)
			}
			i.SolutionEntities = append(i.SolutionEntities, value)
		}
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaPoll) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaPoll.
var (
	_ bin.Encoder = &InputMediaPoll{}
	_ bin.Decoder = &InputMediaPoll{}

	_ InputMediaClass = &InputMediaPoll{}
)

// InputMediaDice represents TL type `inputMediaDice#e66fbf7b`.
// Send a dice-based animated sticker¹
//
// Links:
//  1) https://core.telegram.org/api/dice
//
// See https://core.telegram.org/constructor/inputMediaDice for reference.
type InputMediaDice struct {
	// The emoji, for now ,  and  are supported
	Emoticon string
}

// InputMediaDiceTypeID is TL type id of InputMediaDice.
const InputMediaDiceTypeID = 0xe66fbf7b

// String implements fmt.Stringer.
func (i *InputMediaDice) String() string {
	if i == nil {
		return "InputMediaDice(nil)"
	}
	var sb strings.Builder
	sb.WriteString("InputMediaDice")
	sb.WriteString("{\n")
	sb.WriteString("\tEmoticon: ")
	sb.WriteString(fmt.Sprint(i.Emoticon))
	sb.WriteString(",\n")
	sb.WriteString("}")
	return sb.String()
}

// Encode implements bin.Encoder.
func (i *InputMediaDice) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode inputMediaDice#e66fbf7b as nil")
	}
	b.PutID(InputMediaDiceTypeID)
	b.PutString(i.Emoticon)
	return nil
}

// Decode implements bin.Decoder.
func (i *InputMediaDice) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode inputMediaDice#e66fbf7b to nil")
	}
	if err := b.ConsumeID(InputMediaDiceTypeID); err != nil {
		return fmt.Errorf("unable to decode inputMediaDice#e66fbf7b: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode inputMediaDice#e66fbf7b: field emoticon: %w", err)
		}
		i.Emoticon = value
	}
	return nil
}

// construct implements constructor of InputMediaClass.
func (i InputMediaDice) construct() InputMediaClass { return &i }

// Ensuring interfaces in compile-time for InputMediaDice.
var (
	_ bin.Encoder = &InputMediaDice{}
	_ bin.Decoder = &InputMediaDice{}

	_ InputMediaClass = &InputMediaDice{}
)

// InputMediaClass represents InputMedia generic type.
//
// See https://core.telegram.org/type/InputMedia for reference.
//
// Example:
//  g, err := DecodeInputMedia(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *InputMediaEmpty: // inputMediaEmpty#9664f57f
//  case *InputMediaUploadedPhoto: // inputMediaUploadedPhoto#1e287d04
//  case *InputMediaPhoto: // inputMediaPhoto#b3ba0635
//  case *InputMediaGeoPoint: // inputMediaGeoPoint#f9c44144
//  case *InputMediaContact: // inputMediaContact#f8ab7dfb
//  case *InputMediaUploadedDocument: // inputMediaUploadedDocument#5b38c6c1
//  case *InputMediaDocument: // inputMediaDocument#33473058
//  case *InputMediaVenue: // inputMediaVenue#c13d1c11
//  case *InputMediaPhotoExternal: // inputMediaPhotoExternal#e5bbfe1a
//  case *InputMediaDocumentExternal: // inputMediaDocumentExternal#fb52dc99
//  case *InputMediaGame: // inputMediaGame#d33f43f3
//  case *InputMediaInvoice: // inputMediaInvoice#f4e096c3
//  case *InputMediaGeoLive: // inputMediaGeoLive#971fa843
//  case *InputMediaPoll: // inputMediaPoll#f94e5f1
//  case *InputMediaDice: // inputMediaDice#e66fbf7b
//  default: panic(v)
//  }
type InputMediaClass interface {
	bin.Encoder
	bin.Decoder
	construct() InputMediaClass
	fmt.Stringer
}

// DecodeInputMedia implements binary de-serialization for InputMediaClass.
func DecodeInputMedia(buf *bin.Buffer) (InputMediaClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case InputMediaEmptyTypeID:
		// Decoding inputMediaEmpty#9664f57f.
		v := InputMediaEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaUploadedPhotoTypeID:
		// Decoding inputMediaUploadedPhoto#1e287d04.
		v := InputMediaUploadedPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPhotoTypeID:
		// Decoding inputMediaPhoto#b3ba0635.
		v := InputMediaPhoto{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGeoPointTypeID:
		// Decoding inputMediaGeoPoint#f9c44144.
		v := InputMediaGeoPoint{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaContactTypeID:
		// Decoding inputMediaContact#f8ab7dfb.
		v := InputMediaContact{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaUploadedDocumentTypeID:
		// Decoding inputMediaUploadedDocument#5b38c6c1.
		v := InputMediaUploadedDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDocumentTypeID:
		// Decoding inputMediaDocument#33473058.
		v := InputMediaDocument{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaVenueTypeID:
		// Decoding inputMediaVenue#c13d1c11.
		v := InputMediaVenue{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPhotoExternalTypeID:
		// Decoding inputMediaPhotoExternal#e5bbfe1a.
		v := InputMediaPhotoExternal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDocumentExternalTypeID:
		// Decoding inputMediaDocumentExternal#fb52dc99.
		v := InputMediaDocumentExternal{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGameTypeID:
		// Decoding inputMediaGame#d33f43f3.
		v := InputMediaGame{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaInvoiceTypeID:
		// Decoding inputMediaInvoice#f4e096c3.
		v := InputMediaInvoice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaGeoLiveTypeID:
		// Decoding inputMediaGeoLive#971fa843.
		v := InputMediaGeoLive{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaPollTypeID:
		// Decoding inputMediaPoll#f94e5f1.
		v := InputMediaPoll{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	case InputMediaDiceTypeID:
		// Decoding inputMediaDice#e66fbf7b.
		v := InputMediaDice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode InputMediaClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode InputMediaClass: %w", bin.NewUnexpectedID(id))
	}
}

// InputMedia boxes the InputMediaClass providing a helper.
type InputMediaBox struct {
	InputMedia InputMediaClass
}

// Decode implements bin.Decoder for InputMediaBox.
func (b *InputMediaBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode InputMediaBox to nil")
	}
	v, err := DecodeInputMedia(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.InputMedia = v
	return nil
}

// Encode implements bin.Encode for InputMediaBox.
func (b *InputMediaBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.InputMedia == nil {
		return fmt.Errorf("unable to encode InputMediaClass as nil")
	}
	return b.InputMedia.Encode(buf)
}
