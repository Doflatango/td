// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdp"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)
var _ = strings.Builder{}
var _ = errors.Is
var _ = sort.Ints
var _ = tdp.Format

// JsonNull represents TL type `jsonNull#3f6d7b68`.
// null JSON value
//
// See https://core.telegram.org/constructor/jsonNull for reference.
type JsonNull struct {
}

// JsonNullTypeID is TL type id of JsonNull.
const JsonNullTypeID = 0x3f6d7b68

func (j *JsonNull) Zero() bool {
	if j == nil {
		return true
	}

	return true
}

// String implements fmt.Stringer.
func (j *JsonNull) String() string {
	if j == nil {
		return "JsonNull(nil)"
	}
	type Alias JsonNull
	return fmt.Sprintf("JsonNull%+v", Alias(*j))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*JsonNull) TypeID() uint32 {
	return JsonNullTypeID
}

// TypeName returns name of type in TL schema.
func (*JsonNull) TypeName() string {
	return "jsonNull"
}

// TypeInfo returns info about TL type.
func (j *JsonNull) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "jsonNull",
		ID:   JsonNullTypeID,
	}
	if j == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{}
	return typ
}

// Encode implements bin.Encoder.
func (j *JsonNull) Encode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't encode jsonNull#3f6d7b68 as nil")
	}
	b.PutID(JsonNullTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (j *JsonNull) Decode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't decode jsonNull#3f6d7b68 to nil")
	}
	if err := b.ConsumeID(JsonNullTypeID); err != nil {
		return fmt.Errorf("unable to decode jsonNull#3f6d7b68: %w", err)
	}
	return nil
}

// construct implements constructor of JSONValueClass.
func (j JsonNull) construct() JSONValueClass { return &j }

// Ensuring interfaces in compile-time for JsonNull.
var (
	_ bin.Encoder = &JsonNull{}
	_ bin.Decoder = &JsonNull{}

	_ JSONValueClass = &JsonNull{}
)

// JsonBool represents TL type `jsonBool#c7345e6a`.
// JSON boolean value
//
// See https://core.telegram.org/constructor/jsonBool for reference.
type JsonBool struct {
	// Value
	Value bool `tl:"value"`
}

// JsonBoolTypeID is TL type id of JsonBool.
const JsonBoolTypeID = 0xc7345e6a

func (j *JsonBool) Zero() bool {
	if j == nil {
		return true
	}
	if !(j.Value == false) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (j *JsonBool) String() string {
	if j == nil {
		return "JsonBool(nil)"
	}
	type Alias JsonBool
	return fmt.Sprintf("JsonBool%+v", Alias(*j))
}

// FillFrom fills JsonBool from given interface.
func (j *JsonBool) FillFrom(from interface {
	GetValue() (value bool)
}) {
	j.Value = from.GetValue()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*JsonBool) TypeID() uint32 {
	return JsonBoolTypeID
}

// TypeName returns name of type in TL schema.
func (*JsonBool) TypeName() string {
	return "jsonBool"
}

// TypeInfo returns info about TL type.
func (j *JsonBool) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "jsonBool",
		ID:   JsonBoolTypeID,
	}
	if j == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (j *JsonBool) Encode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't encode jsonBool#c7345e6a as nil")
	}
	b.PutID(JsonBoolTypeID)
	b.PutBool(j.Value)
	return nil
}

// GetValue returns value of Value field.
func (j *JsonBool) GetValue() (value bool) {
	return j.Value
}

// Decode implements bin.Decoder.
func (j *JsonBool) Decode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't decode jsonBool#c7345e6a to nil")
	}
	if err := b.ConsumeID(JsonBoolTypeID); err != nil {
		return fmt.Errorf("unable to decode jsonBool#c7345e6a: %w", err)
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode jsonBool#c7345e6a: field value: %w", err)
		}
		j.Value = value
	}
	return nil
}

// construct implements constructor of JSONValueClass.
func (j JsonBool) construct() JSONValueClass { return &j }

// Ensuring interfaces in compile-time for JsonBool.
var (
	_ bin.Encoder = &JsonBool{}
	_ bin.Decoder = &JsonBool{}

	_ JSONValueClass = &JsonBool{}
)

// JsonNumber represents TL type `jsonNumber#2be0dfa4`.
// JSON numeric value
//
// See https://core.telegram.org/constructor/jsonNumber for reference.
type JsonNumber struct {
	// Value
	Value float64 `tl:"value"`
}

// JsonNumberTypeID is TL type id of JsonNumber.
const JsonNumberTypeID = 0x2be0dfa4

func (j *JsonNumber) Zero() bool {
	if j == nil {
		return true
	}
	if !(j.Value == 0) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (j *JsonNumber) String() string {
	if j == nil {
		return "JsonNumber(nil)"
	}
	type Alias JsonNumber
	return fmt.Sprintf("JsonNumber%+v", Alias(*j))
}

// FillFrom fills JsonNumber from given interface.
func (j *JsonNumber) FillFrom(from interface {
	GetValue() (value float64)
}) {
	j.Value = from.GetValue()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*JsonNumber) TypeID() uint32 {
	return JsonNumberTypeID
}

// TypeName returns name of type in TL schema.
func (*JsonNumber) TypeName() string {
	return "jsonNumber"
}

// TypeInfo returns info about TL type.
func (j *JsonNumber) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "jsonNumber",
		ID:   JsonNumberTypeID,
	}
	if j == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (j *JsonNumber) Encode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't encode jsonNumber#2be0dfa4 as nil")
	}
	b.PutID(JsonNumberTypeID)
	b.PutDouble(j.Value)
	return nil
}

// GetValue returns value of Value field.
func (j *JsonNumber) GetValue() (value float64) {
	return j.Value
}

// Decode implements bin.Decoder.
func (j *JsonNumber) Decode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't decode jsonNumber#2be0dfa4 to nil")
	}
	if err := b.ConsumeID(JsonNumberTypeID); err != nil {
		return fmt.Errorf("unable to decode jsonNumber#2be0dfa4: %w", err)
	}
	{
		value, err := b.Double()
		if err != nil {
			return fmt.Errorf("unable to decode jsonNumber#2be0dfa4: field value: %w", err)
		}
		j.Value = value
	}
	return nil
}

// construct implements constructor of JSONValueClass.
func (j JsonNumber) construct() JSONValueClass { return &j }

// Ensuring interfaces in compile-time for JsonNumber.
var (
	_ bin.Encoder = &JsonNumber{}
	_ bin.Decoder = &JsonNumber{}

	_ JSONValueClass = &JsonNumber{}
)

// JsonString represents TL type `jsonString#b71e767a`.
// JSON string
//
// See https://core.telegram.org/constructor/jsonString for reference.
type JsonString struct {
	// Value
	Value string `tl:"value"`
}

// JsonStringTypeID is TL type id of JsonString.
const JsonStringTypeID = 0xb71e767a

func (j *JsonString) Zero() bool {
	if j == nil {
		return true
	}
	if !(j.Value == "") {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (j *JsonString) String() string {
	if j == nil {
		return "JsonString(nil)"
	}
	type Alias JsonString
	return fmt.Sprintf("JsonString%+v", Alias(*j))
}

// FillFrom fills JsonString from given interface.
func (j *JsonString) FillFrom(from interface {
	GetValue() (value string)
}) {
	j.Value = from.GetValue()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*JsonString) TypeID() uint32 {
	return JsonStringTypeID
}

// TypeName returns name of type in TL schema.
func (*JsonString) TypeName() string {
	return "jsonString"
}

// TypeInfo returns info about TL type.
func (j *JsonString) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "jsonString",
		ID:   JsonStringTypeID,
	}
	if j == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (j *JsonString) Encode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't encode jsonString#b71e767a as nil")
	}
	b.PutID(JsonStringTypeID)
	b.PutString(j.Value)
	return nil
}

// GetValue returns value of Value field.
func (j *JsonString) GetValue() (value string) {
	return j.Value
}

// Decode implements bin.Decoder.
func (j *JsonString) Decode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't decode jsonString#b71e767a to nil")
	}
	if err := b.ConsumeID(JsonStringTypeID); err != nil {
		return fmt.Errorf("unable to decode jsonString#b71e767a: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode jsonString#b71e767a: field value: %w", err)
		}
		j.Value = value
	}
	return nil
}

// construct implements constructor of JSONValueClass.
func (j JsonString) construct() JSONValueClass { return &j }

// Ensuring interfaces in compile-time for JsonString.
var (
	_ bin.Encoder = &JsonString{}
	_ bin.Decoder = &JsonString{}

	_ JSONValueClass = &JsonString{}
)

// JsonArray represents TL type `jsonArray#f7444763`.
// JSON array
//
// See https://core.telegram.org/constructor/jsonArray for reference.
type JsonArray struct {
	// JSON values
	Value []JSONValueClass `tl:"value"`
}

// JsonArrayTypeID is TL type id of JsonArray.
const JsonArrayTypeID = 0xf7444763

func (j *JsonArray) Zero() bool {
	if j == nil {
		return true
	}
	if !(j.Value == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (j *JsonArray) String() string {
	if j == nil {
		return "JsonArray(nil)"
	}
	type Alias JsonArray
	return fmt.Sprintf("JsonArray%+v", Alias(*j))
}

// FillFrom fills JsonArray from given interface.
func (j *JsonArray) FillFrom(from interface {
	GetValue() (value []JSONValueClass)
}) {
	j.Value = from.GetValue()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*JsonArray) TypeID() uint32 {
	return JsonArrayTypeID
}

// TypeName returns name of type in TL schema.
func (*JsonArray) TypeName() string {
	return "jsonArray"
}

// TypeInfo returns info about TL type.
func (j *JsonArray) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "jsonArray",
		ID:   JsonArrayTypeID,
	}
	if j == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (j *JsonArray) Encode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't encode jsonArray#f7444763 as nil")
	}
	b.PutID(JsonArrayTypeID)
	b.PutVectorHeader(len(j.Value))
	for idx, v := range j.Value {
		if v == nil {
			return fmt.Errorf("unable to encode jsonArray#f7444763: field value element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode jsonArray#f7444763: field value element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetValue returns value of Value field.
func (j *JsonArray) GetValue() (value []JSONValueClass) {
	return j.Value
}

// MapValue returns field Value wrapped in JSONValueClassArray helper.
func (j *JsonArray) MapValue() (value JSONValueClassArray) {
	return JSONValueClassArray(j.Value)
}

// Decode implements bin.Decoder.
func (j *JsonArray) Decode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't decode jsonArray#f7444763 to nil")
	}
	if err := b.ConsumeID(JsonArrayTypeID); err != nil {
		return fmt.Errorf("unable to decode jsonArray#f7444763: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode jsonArray#f7444763: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeJSONValue(b)
			if err != nil {
				return fmt.Errorf("unable to decode jsonArray#f7444763: field value: %w", err)
			}
			j.Value = append(j.Value, value)
		}
	}
	return nil
}

// construct implements constructor of JSONValueClass.
func (j JsonArray) construct() JSONValueClass { return &j }

// Ensuring interfaces in compile-time for JsonArray.
var (
	_ bin.Encoder = &JsonArray{}
	_ bin.Decoder = &JsonArray{}

	_ JSONValueClass = &JsonArray{}
)

// JsonObject represents TL type `jsonObject#99c1d49d`.
// JSON object value
//
// See https://core.telegram.org/constructor/jsonObject for reference.
type JsonObject struct {
	// Values
	Value []JsonObjectValue `tl:"value"`
}

// JsonObjectTypeID is TL type id of JsonObject.
const JsonObjectTypeID = 0x99c1d49d

func (j *JsonObject) Zero() bool {
	if j == nil {
		return true
	}
	if !(j.Value == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (j *JsonObject) String() string {
	if j == nil {
		return "JsonObject(nil)"
	}
	type Alias JsonObject
	return fmt.Sprintf("JsonObject%+v", Alias(*j))
}

// FillFrom fills JsonObject from given interface.
func (j *JsonObject) FillFrom(from interface {
	GetValue() (value []JsonObjectValue)
}) {
	j.Value = from.GetValue()
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*JsonObject) TypeID() uint32 {
	return JsonObjectTypeID
}

// TypeName returns name of type in TL schema.
func (*JsonObject) TypeName() string {
	return "jsonObject"
}

// TypeInfo returns info about TL type.
func (j *JsonObject) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "jsonObject",
		ID:   JsonObjectTypeID,
	}
	if j == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "Value",
			SchemaName: "value",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (j *JsonObject) Encode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't encode jsonObject#99c1d49d as nil")
	}
	b.PutID(JsonObjectTypeID)
	b.PutVectorHeader(len(j.Value))
	for idx, v := range j.Value {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode jsonObject#99c1d49d: field value element with index %d: %w", idx, err)
		}
	}
	return nil
}

// GetValue returns value of Value field.
func (j *JsonObject) GetValue() (value []JsonObjectValue) {
	return j.Value
}

// Decode implements bin.Decoder.
func (j *JsonObject) Decode(b *bin.Buffer) error {
	if j == nil {
		return fmt.Errorf("can't decode jsonObject#99c1d49d to nil")
	}
	if err := b.ConsumeID(JsonObjectTypeID); err != nil {
		return fmt.Errorf("unable to decode jsonObject#99c1d49d: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode jsonObject#99c1d49d: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value JsonObjectValue
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode jsonObject#99c1d49d: field value: %w", err)
			}
			j.Value = append(j.Value, value)
		}
	}
	return nil
}

// construct implements constructor of JSONValueClass.
func (j JsonObject) construct() JSONValueClass { return &j }

// Ensuring interfaces in compile-time for JsonObject.
var (
	_ bin.Encoder = &JsonObject{}
	_ bin.Decoder = &JsonObject{}

	_ JSONValueClass = &JsonObject{}
)

// JSONValueClass represents JSONValue generic type.
//
// See https://core.telegram.org/type/JSONValue for reference.
//
// Example:
//  g, err := tg.DecodeJSONValue(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *tg.JsonNull: // jsonNull#3f6d7b68
//  case *tg.JsonBool: // jsonBool#c7345e6a
//  case *tg.JsonNumber: // jsonNumber#2be0dfa4
//  case *tg.JsonString: // jsonString#b71e767a
//  case *tg.JsonArray: // jsonArray#f7444763
//  case *tg.JsonObject: // jsonObject#99c1d49d
//  default: panic(v)
//  }
type JSONValueClass interface {
	bin.Encoder
	bin.Decoder
	construct() JSONValueClass

	// TypeID returns type id in TL schema.
	//
	// See https://core.telegram.org/mtproto/TL-tl#remarks.
	TypeID() uint32
	// TypeName returns name of type in TL schema.
	TypeName() string
	// String implements fmt.Stringer.
	String() string
	// Zero returns true if current object has a zero value.
	Zero() bool
}

// DecodeJSONValue implements binary de-serialization for JSONValueClass.
func DecodeJSONValue(buf *bin.Buffer) (JSONValueClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case JsonNullTypeID:
		// Decoding jsonNull#3f6d7b68.
		v := JsonNull{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode JSONValueClass: %w", err)
		}
		return &v, nil
	case JsonBoolTypeID:
		// Decoding jsonBool#c7345e6a.
		v := JsonBool{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode JSONValueClass: %w", err)
		}
		return &v, nil
	case JsonNumberTypeID:
		// Decoding jsonNumber#2be0dfa4.
		v := JsonNumber{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode JSONValueClass: %w", err)
		}
		return &v, nil
	case JsonStringTypeID:
		// Decoding jsonString#b71e767a.
		v := JsonString{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode JSONValueClass: %w", err)
		}
		return &v, nil
	case JsonArrayTypeID:
		// Decoding jsonArray#f7444763.
		v := JsonArray{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode JSONValueClass: %w", err)
		}
		return &v, nil
	case JsonObjectTypeID:
		// Decoding jsonObject#99c1d49d.
		v := JsonObject{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode JSONValueClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode JSONValueClass: %w", bin.NewUnexpectedID(id))
	}
}

// JSONValue boxes the JSONValueClass providing a helper.
type JSONValueBox struct {
	JSONValue JSONValueClass
}

// Decode implements bin.Decoder for JSONValueBox.
func (b *JSONValueBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode JSONValueBox to nil")
	}
	v, err := DecodeJSONValue(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.JSONValue = v
	return nil
}

// Encode implements bin.Encode for JSONValueBox.
func (b *JSONValueBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.JSONValue == nil {
		return fmt.Errorf("unable to encode JSONValueClass as nil")
	}
	return b.JSONValue.Encode(buf)
}

// JSONValueClassArray is adapter for slice of JSONValueClass.
type JSONValueClassArray []JSONValueClass

// Sort sorts slice of JSONValueClass.
func (s JSONValueClassArray) Sort(less func(a, b JSONValueClass) bool) JSONValueClassArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of JSONValueClass.
func (s JSONValueClassArray) SortStable(less func(a, b JSONValueClass) bool) JSONValueClassArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of JSONValueClass.
func (s JSONValueClassArray) Retain(keep func(x JSONValueClass) bool) JSONValueClassArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s JSONValueClassArray) First() (v JSONValueClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s JSONValueClassArray) Last() (v JSONValueClass, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *JSONValueClassArray) PopFirst() (v JSONValueClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero JSONValueClass
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *JSONValueClassArray) Pop() (v JSONValueClass, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// AsJsonBool returns copy with only JsonBool constructors.
func (s JSONValueClassArray) AsJsonBool() (to JsonBoolArray) {
	for _, elem := range s {
		value, ok := elem.(*JsonBool)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsJsonNumber returns copy with only JsonNumber constructors.
func (s JSONValueClassArray) AsJsonNumber() (to JsonNumberArray) {
	for _, elem := range s {
		value, ok := elem.(*JsonNumber)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsJsonString returns copy with only JsonString constructors.
func (s JSONValueClassArray) AsJsonString() (to JsonStringArray) {
	for _, elem := range s {
		value, ok := elem.(*JsonString)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsJsonArray returns copy with only JsonArray constructors.
func (s JSONValueClassArray) AsJsonArray() (to JsonArrayArray) {
	for _, elem := range s {
		value, ok := elem.(*JsonArray)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// AsJsonObject returns copy with only JsonObject constructors.
func (s JSONValueClassArray) AsJsonObject() (to JsonObjectArray) {
	for _, elem := range s {
		value, ok := elem.(*JsonObject)
		if !ok {
			continue
		}
		to = append(to, *value)
	}

	return to
}

// JsonBoolArray is adapter for slice of JsonBool.
type JsonBoolArray []JsonBool

// Sort sorts slice of JsonBool.
func (s JsonBoolArray) Sort(less func(a, b JsonBool) bool) JsonBoolArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of JsonBool.
func (s JsonBoolArray) SortStable(less func(a, b JsonBool) bool) JsonBoolArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of JsonBool.
func (s JsonBoolArray) Retain(keep func(x JsonBool) bool) JsonBoolArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s JsonBoolArray) First() (v JsonBool, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s JsonBoolArray) Last() (v JsonBool, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *JsonBoolArray) PopFirst() (v JsonBool, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero JsonBool
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *JsonBoolArray) Pop() (v JsonBool, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// JsonNumberArray is adapter for slice of JsonNumber.
type JsonNumberArray []JsonNumber

// Sort sorts slice of JsonNumber.
func (s JsonNumberArray) Sort(less func(a, b JsonNumber) bool) JsonNumberArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of JsonNumber.
func (s JsonNumberArray) SortStable(less func(a, b JsonNumber) bool) JsonNumberArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of JsonNumber.
func (s JsonNumberArray) Retain(keep func(x JsonNumber) bool) JsonNumberArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s JsonNumberArray) First() (v JsonNumber, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s JsonNumberArray) Last() (v JsonNumber, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *JsonNumberArray) PopFirst() (v JsonNumber, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero JsonNumber
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *JsonNumberArray) Pop() (v JsonNumber, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// JsonStringArray is adapter for slice of JsonString.
type JsonStringArray []JsonString

// Sort sorts slice of JsonString.
func (s JsonStringArray) Sort(less func(a, b JsonString) bool) JsonStringArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of JsonString.
func (s JsonStringArray) SortStable(less func(a, b JsonString) bool) JsonStringArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of JsonString.
func (s JsonStringArray) Retain(keep func(x JsonString) bool) JsonStringArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s JsonStringArray) First() (v JsonString, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s JsonStringArray) Last() (v JsonString, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *JsonStringArray) PopFirst() (v JsonString, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero JsonString
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *JsonStringArray) Pop() (v JsonString, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// JsonArrayArray is adapter for slice of JsonArray.
type JsonArrayArray []JsonArray

// Sort sorts slice of JsonArray.
func (s JsonArrayArray) Sort(less func(a, b JsonArray) bool) JsonArrayArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of JsonArray.
func (s JsonArrayArray) SortStable(less func(a, b JsonArray) bool) JsonArrayArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of JsonArray.
func (s JsonArrayArray) Retain(keep func(x JsonArray) bool) JsonArrayArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s JsonArrayArray) First() (v JsonArray, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s JsonArrayArray) Last() (v JsonArray, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *JsonArrayArray) PopFirst() (v JsonArray, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero JsonArray
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *JsonArrayArray) Pop() (v JsonArray, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// JsonObjectArray is adapter for slice of JsonObject.
type JsonObjectArray []JsonObject

// Sort sorts slice of JsonObject.
func (s JsonObjectArray) Sort(less func(a, b JsonObject) bool) JsonObjectArray {
	sort.Slice(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// SortStable sorts slice of JsonObject.
func (s JsonObjectArray) SortStable(less func(a, b JsonObject) bool) JsonObjectArray {
	sort.SliceStable(s, func(i, j int) bool {
		return less(s[i], s[j])
	})
	return s
}

// Retain filters in-place slice of JsonObject.
func (s JsonObjectArray) Retain(keep func(x JsonObject) bool) JsonObjectArray {
	n := 0
	for _, x := range s {
		if keep(x) {
			s[n] = x
			n++
		}
	}
	s = s[:n]

	return s
}

// First returns first element of slice (if exists).
func (s JsonObjectArray) First() (v JsonObject, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[0], true
}

// Last returns last element of slice (if exists).
func (s JsonObjectArray) Last() (v JsonObject, ok bool) {
	if len(s) < 1 {
		return
	}
	return s[len(s)-1], true
}

// PopFirst returns first element of slice (if exists) and deletes it.
func (s *JsonObjectArray) PopFirst() (v JsonObject, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[0]

	// Delete by index from SliceTricks.
	copy(a[0:], a[1:])
	var zero JsonObject
	a[len(a)-1] = zero
	a = a[:len(a)-1]
	*s = a

	return v, true
}

// Pop returns last element of slice (if exists) and deletes it.
func (s *JsonObjectArray) Pop() (v JsonObject, ok bool) {
	if s == nil || len(*s) < 1 {
		return
	}

	a := *s
	v = a[len(a)-1]
	a = a[:len(a)-1]
	*s = a

	return v, true
}
