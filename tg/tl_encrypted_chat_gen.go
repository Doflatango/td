// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"fmt"

	"github.com/gotd/td/bin"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)

// EncryptedChatEmpty represents TL type `encryptedChatEmpty#ab7ec0a0`.
// Empty constructor.
//
// See https://core.telegram.org/constructor/encryptedChatEmpty for reference.
type EncryptedChatEmpty struct {
	// Chat ID
	ID int
}

// EncryptedChatEmptyTypeID is TL type id of EncryptedChatEmpty.
const EncryptedChatEmptyTypeID = 0xab7ec0a0

// Encode implements bin.Encoder.
func (e *EncryptedChatEmpty) Encode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't encode encryptedChatEmpty#ab7ec0a0 as nil")
	}
	b.PutID(EncryptedChatEmptyTypeID)
	b.PutInt(e.ID)
	return nil
}

// Decode implements bin.Decoder.
func (e *EncryptedChatEmpty) Decode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't decode encryptedChatEmpty#ab7ec0a0 to nil")
	}
	if err := b.ConsumeID(EncryptedChatEmptyTypeID); err != nil {
		return fmt.Errorf("unable to decode encryptedChatEmpty#ab7ec0a0: %w", err)
	}

	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatEmpty#ab7ec0a0: field id: %w", err)
		}
		e.ID = value
	}
	return nil
}

// construct implements constructor of EncryptedChatClass.
func (e EncryptedChatEmpty) construct() EncryptedChatClass { return &e }

// Ensuring interfaces in compile-time for EncryptedChatEmpty.
var (
	_ bin.Encoder = &EncryptedChatEmpty{}
	_ bin.Decoder = &EncryptedChatEmpty{}

	_ EncryptedChatClass = &EncryptedChatEmpty{}
)

// EncryptedChatWaiting represents TL type `encryptedChatWaiting#3bf703dc`.
// Chat waiting for approval of second participant.
//
// See https://core.telegram.org/constructor/encryptedChatWaiting for reference.
type EncryptedChatWaiting struct {
	// Chat ID
	ID int
	// Checking sum depending on user ID
	AccessHash int64
	// Date of chat creation
	Date int
	// Chat creator ID
	AdminID int
	// ID of second chat participant
	ParticipantID int
}

// EncryptedChatWaitingTypeID is TL type id of EncryptedChatWaiting.
const EncryptedChatWaitingTypeID = 0x3bf703dc

// Encode implements bin.Encoder.
func (e *EncryptedChatWaiting) Encode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't encode encryptedChatWaiting#3bf703dc as nil")
	}
	b.PutID(EncryptedChatWaitingTypeID)
	b.PutInt(e.ID)
	b.PutLong(e.AccessHash)
	b.PutInt(e.Date)
	b.PutInt(e.AdminID)
	b.PutInt(e.ParticipantID)
	return nil
}

// Decode implements bin.Decoder.
func (e *EncryptedChatWaiting) Decode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't decode encryptedChatWaiting#3bf703dc to nil")
	}
	if err := b.ConsumeID(EncryptedChatWaitingTypeID); err != nil {
		return fmt.Errorf("unable to decode encryptedChatWaiting#3bf703dc: %w", err)
	}

	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatWaiting#3bf703dc: field id: %w", err)
		}
		e.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatWaiting#3bf703dc: field access_hash: %w", err)
		}
		e.AccessHash = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatWaiting#3bf703dc: field date: %w", err)
		}
		e.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatWaiting#3bf703dc: field admin_id: %w", err)
		}
		e.AdminID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatWaiting#3bf703dc: field participant_id: %w", err)
		}
		e.ParticipantID = value
	}
	return nil
}

// construct implements constructor of EncryptedChatClass.
func (e EncryptedChatWaiting) construct() EncryptedChatClass { return &e }

// Ensuring interfaces in compile-time for EncryptedChatWaiting.
var (
	_ bin.Encoder = &EncryptedChatWaiting{}
	_ bin.Decoder = &EncryptedChatWaiting{}

	_ EncryptedChatClass = &EncryptedChatWaiting{}
)

// EncryptedChatRequested represents TL type `encryptedChatRequested#62718a82`.
// Request to create an encrypted chat.
//
// See https://core.telegram.org/constructor/encryptedChatRequested for reference.
type EncryptedChatRequested struct {
	// Flags, see TL conditional fields
	Flags bin.Fields
	// Peer folder ID, for more info click here
	//
	// Use SetFolderID and GetFolderID helpers.
	FolderID int
	// Chat ID
	ID int
	// Check sum depending on user ID
	AccessHash int64
	// Chat creation date
	Date int
	// Chat creator ID
	AdminID int
	// ID of second chat participant
	ParticipantID int
	// A = g ^ a mod p, see Wikipedia
	GA []byte
}

// EncryptedChatRequestedTypeID is TL type id of EncryptedChatRequested.
const EncryptedChatRequestedTypeID = 0x62718a82

// Encode implements bin.Encoder.
func (e *EncryptedChatRequested) Encode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't encode encryptedChatRequested#62718a82 as nil")
	}
	b.PutID(EncryptedChatRequestedTypeID)
	if err := e.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode encryptedChatRequested#62718a82: field flags: %w", err)
	}
	if e.Flags.Has(0) {
		b.PutInt(e.FolderID)
	}
	b.PutInt(e.ID)
	b.PutLong(e.AccessHash)
	b.PutInt(e.Date)
	b.PutInt(e.AdminID)
	b.PutInt(e.ParticipantID)
	b.PutBytes(e.GA)
	return nil
}

// SetFolderID sets value of FolderID conditional field.
func (e *EncryptedChatRequested) SetFolderID(value int) {
	e.Flags.Set(0)
	e.FolderID = value
}

// GetFolderID returns value of FolderID conditional field and
// boolean which is true if field was set.
func (e *EncryptedChatRequested) GetFolderID() (value int, ok bool) {
	if !e.Flags.Has(0) {
		return value, false
	}
	return e.FolderID, true
}

// Decode implements bin.Decoder.
func (e *EncryptedChatRequested) Decode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't decode encryptedChatRequested#62718a82 to nil")
	}
	if err := b.ConsumeID(EncryptedChatRequestedTypeID); err != nil {
		return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: %w", err)
	}

	{
		if err := e.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field flags: %w", err)
		}
	}
	if e.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field folder_id: %w", err)
		}
		e.FolderID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field id: %w", err)
		}
		e.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field access_hash: %w", err)
		}
		e.AccessHash = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field date: %w", err)
		}
		e.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field admin_id: %w", err)
		}
		e.AdminID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field participant_id: %w", err)
		}
		e.ParticipantID = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatRequested#62718a82: field g_a: %w", err)
		}
		e.GA = value
	}
	return nil
}

// construct implements constructor of EncryptedChatClass.
func (e EncryptedChatRequested) construct() EncryptedChatClass { return &e }

// Ensuring interfaces in compile-time for EncryptedChatRequested.
var (
	_ bin.Encoder = &EncryptedChatRequested{}
	_ bin.Decoder = &EncryptedChatRequested{}

	_ EncryptedChatClass = &EncryptedChatRequested{}
)

// EncryptedChat represents TL type `encryptedChat#fa56ce36`.
// Encrypted chat
//
// See https://core.telegram.org/constructor/encryptedChat for reference.
type EncryptedChat struct {
	// Chat ID
	ID int
	// Check sum dependant on the user ID
	AccessHash int64
	// Date chat was created
	Date int
	// Chat creator ID
	AdminID int
	// ID of the second chat participant
	ParticipantID int
	// B = g ^ b mod p, if the currently authorized user is the chat's creator,or A = g ^ a mod p otherwiseSee Wikipedia for more info
	GAOrB []byte
	// 64-bit fingerprint of received key
	KeyFingerprint int64
}

// EncryptedChatTypeID is TL type id of EncryptedChat.
const EncryptedChatTypeID = 0xfa56ce36

// Encode implements bin.Encoder.
func (e *EncryptedChat) Encode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't encode encryptedChat#fa56ce36 as nil")
	}
	b.PutID(EncryptedChatTypeID)
	b.PutInt(e.ID)
	b.PutLong(e.AccessHash)
	b.PutInt(e.Date)
	b.PutInt(e.AdminID)
	b.PutInt(e.ParticipantID)
	b.PutBytes(e.GAOrB)
	b.PutLong(e.KeyFingerprint)
	return nil
}

// Decode implements bin.Decoder.
func (e *EncryptedChat) Decode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't decode encryptedChat#fa56ce36 to nil")
	}
	if err := b.ConsumeID(EncryptedChatTypeID); err != nil {
		return fmt.Errorf("unable to decode encryptedChat#fa56ce36: %w", err)
	}

	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field id: %w", err)
		}
		e.ID = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field access_hash: %w", err)
		}
		e.AccessHash = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field date: %w", err)
		}
		e.Date = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field admin_id: %w", err)
		}
		e.AdminID = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field participant_id: %w", err)
		}
		e.ParticipantID = value
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field g_a_or_b: %w", err)
		}
		e.GAOrB = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChat#fa56ce36: field key_fingerprint: %w", err)
		}
		e.KeyFingerprint = value
	}
	return nil
}

// construct implements constructor of EncryptedChatClass.
func (e EncryptedChat) construct() EncryptedChatClass { return &e }

// Ensuring interfaces in compile-time for EncryptedChat.
var (
	_ bin.Encoder = &EncryptedChat{}
	_ bin.Decoder = &EncryptedChat{}

	_ EncryptedChatClass = &EncryptedChat{}
)

// EncryptedChatDiscarded represents TL type `encryptedChatDiscarded#13d6dd27`.
// Discarded or deleted chat.
//
// See https://core.telegram.org/constructor/encryptedChatDiscarded for reference.
type EncryptedChatDiscarded struct {
	// Chat ID
	ID int
}

// EncryptedChatDiscardedTypeID is TL type id of EncryptedChatDiscarded.
const EncryptedChatDiscardedTypeID = 0x13d6dd27

// Encode implements bin.Encoder.
func (e *EncryptedChatDiscarded) Encode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't encode encryptedChatDiscarded#13d6dd27 as nil")
	}
	b.PutID(EncryptedChatDiscardedTypeID)
	b.PutInt(e.ID)
	return nil
}

// Decode implements bin.Decoder.
func (e *EncryptedChatDiscarded) Decode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't decode encryptedChatDiscarded#13d6dd27 to nil")
	}
	if err := b.ConsumeID(EncryptedChatDiscardedTypeID); err != nil {
		return fmt.Errorf("unable to decode encryptedChatDiscarded#13d6dd27: %w", err)
	}

	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode encryptedChatDiscarded#13d6dd27: field id: %w", err)
		}
		e.ID = value
	}
	return nil
}

// construct implements constructor of EncryptedChatClass.
func (e EncryptedChatDiscarded) construct() EncryptedChatClass { return &e }

// Ensuring interfaces in compile-time for EncryptedChatDiscarded.
var (
	_ bin.Encoder = &EncryptedChatDiscarded{}
	_ bin.Decoder = &EncryptedChatDiscarded{}

	_ EncryptedChatClass = &EncryptedChatDiscarded{}
)

// EncryptedChatClass represents EncryptedChat generic type.
//
// See https://core.telegram.org/type/EncryptedChat for reference.
//
// Example:
//  g, err := DecodeEncryptedChat(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *EncryptedChatEmpty: // encryptedChatEmpty#ab7ec0a0
//  case *EncryptedChatWaiting: // encryptedChatWaiting#3bf703dc
//  case *EncryptedChatRequested: // encryptedChatRequested#62718a82
//  case *EncryptedChat: // encryptedChat#fa56ce36
//  case *EncryptedChatDiscarded: // encryptedChatDiscarded#13d6dd27
//  default: panic(v)
//  }
type EncryptedChatClass interface {
	bin.Encoder
	bin.Decoder
	construct() EncryptedChatClass
}

// DecodeEncryptedChat implements binary de-serialization for EncryptedChatClass.
func DecodeEncryptedChat(buf *bin.Buffer) (EncryptedChatClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case EncryptedChatEmptyTypeID:
		// Decoding encryptedChatEmpty#ab7ec0a0.
		v := EncryptedChatEmpty{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode EncryptedChatClass: %w", err)
		}
		return &v, nil
	case EncryptedChatWaitingTypeID:
		// Decoding encryptedChatWaiting#3bf703dc.
		v := EncryptedChatWaiting{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode EncryptedChatClass: %w", err)
		}
		return &v, nil
	case EncryptedChatRequestedTypeID:
		// Decoding encryptedChatRequested#62718a82.
		v := EncryptedChatRequested{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode EncryptedChatClass: %w", err)
		}
		return &v, nil
	case EncryptedChatTypeID:
		// Decoding encryptedChat#fa56ce36.
		v := EncryptedChat{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode EncryptedChatClass: %w", err)
		}
		return &v, nil
	case EncryptedChatDiscardedTypeID:
		// Decoding encryptedChatDiscarded#13d6dd27.
		v := EncryptedChatDiscarded{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode EncryptedChatClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode EncryptedChatClass: %w", bin.NewUnexpectedID(id))
	}
}

// EncryptedChat boxes the EncryptedChatClass providing a helper.
type EncryptedChatBox struct {
	EncryptedChat EncryptedChatClass
}

// Decode implements bin.Decoder for EncryptedChatBox.
func (b *EncryptedChatBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode EncryptedChatBox to nil")
	}
	v, err := DecodeEncryptedChat(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.EncryptedChat = v
	return nil
}

// Encode implements bin.Encode for EncryptedChatBox.
func (b *EncryptedChatBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.EncryptedChat == nil {
		return fmt.Errorf("unable to encode EncryptedChatClass as nil")
	}
	return b.EncryptedChat.Encode(buf)
}
