// Code generated by gotdgen, DO NOT EDIT.

package tg

import (
	"context"
	"fmt"

	"github.com/gotd/td/bin"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}
var _ = context.Background()
var _ = fmt.Stringer(nil)

// MessagesMessages represents TL type `messages.messages#8c718e87`.
//
// See https://core.telegram.org/constructor/messages.messages for reference.
type MessagesMessages struct {
	// Messages field of MessagesMessages.
	Messages []MessageClass
	// Chats field of MessagesMessages.
	Chats []ChatClass
	// Users field of MessagesMessages.
	Users []UserClass
}

// MessagesMessagesTypeID is TL type id of MessagesMessages.
const MessagesMessagesTypeID = 0x8c718e87

// Encode implements bin.Encoder.
func (m *MessagesMessages) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messages.messages#8c718e87 as nil")
	}
	b.PutID(MessagesMessagesTypeID)
	b.PutVectorHeader(len(m.Messages))
	for idx, v := range m.Messages {
		if v == nil {
			return fmt.Errorf("unable to encode messages.messages#8c718e87: field messages element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.messages#8c718e87: field messages element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(m.Chats))
	for idx, v := range m.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode messages.messages#8c718e87: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.messages#8c718e87: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(m.Users))
	for idx, v := range m.Users {
		if v == nil {
			return fmt.Errorf("unable to encode messages.messages#8c718e87: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.messages#8c718e87: field users element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagesMessages) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messages.messages#8c718e87 to nil")
	}
	if err := b.ConsumeID(MessagesMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode messages.messages#8c718e87: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messages#8c718e87: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessage(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.messages#8c718e87: field messages: %w", err)
			}
			m.Messages = append(m.Messages, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messages#8c718e87: field chats: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.messages#8c718e87: field chats: %w", err)
			}
			m.Chats = append(m.Chats, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messages#8c718e87: field users: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.messages#8c718e87: field users: %w", err)
			}
			m.Users = append(m.Users, value)
		}
	}
	return nil
}

// construct implements constructor of MessagesMessagesClass.
func (m MessagesMessages) construct() MessagesMessagesClass { return &m }

// Ensuring interfaces in compile-time for MessagesMessages.
var (
	_ bin.Encoder = &MessagesMessages{}
	_ bin.Decoder = &MessagesMessages{}

	_ MessagesMessagesClass = &MessagesMessages{}
)

// MessagesMessagesSlice represents TL type `messages.messagesSlice#3a54685e`.
//
// See https://core.telegram.org/constructor/messages.messagesSlice for reference.
type MessagesMessagesSlice struct {
	// Flags field of MessagesMessagesSlice.
	Flags bin.Fields
	// Inexact field of MessagesMessagesSlice.
	Inexact bool
	// Count field of MessagesMessagesSlice.
	Count int
	// NextRate field of MessagesMessagesSlice.
	//
	// Use SetNextRate and GetNextRate helpers.
	NextRate int
	// OffsetIDOffset field of MessagesMessagesSlice.
	//
	// Use SetOffsetIDOffset and GetOffsetIDOffset helpers.
	OffsetIDOffset int
	// Messages field of MessagesMessagesSlice.
	Messages []MessageClass
	// Chats field of MessagesMessagesSlice.
	Chats []ChatClass
	// Users field of MessagesMessagesSlice.
	Users []UserClass
}

// MessagesMessagesSliceTypeID is TL type id of MessagesMessagesSlice.
const MessagesMessagesSliceTypeID = 0x3a54685e

// Encode implements bin.Encoder.
func (m *MessagesMessagesSlice) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messages.messagesSlice#3a54685e as nil")
	}
	b.PutID(MessagesMessagesSliceTypeID)
	if err := m.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field flags: %w", err)
	}
	b.PutInt(m.Count)
	if m.Flags.Has(0) {
		b.PutInt(m.NextRate)
	}
	if m.Flags.Has(2) {
		b.PutInt(m.OffsetIDOffset)
	}
	b.PutVectorHeader(len(m.Messages))
	for idx, v := range m.Messages {
		if v == nil {
			return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field messages element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field messages element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(m.Chats))
	for idx, v := range m.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(m.Users))
	for idx, v := range m.Users {
		if v == nil {
			return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.messagesSlice#3a54685e: field users element with index %d: %w", idx, err)
		}
	}
	return nil
}

// SetInexact sets value of Inexact conditional field.
func (m *MessagesMessagesSlice) SetInexact(value bool) {
	if value {
		m.Flags.Set(1)
	} else {
		m.Flags.Unset(1)
	}
}

// SetNextRate sets value of NextRate conditional field.
func (m *MessagesMessagesSlice) SetNextRate(value int) {
	m.Flags.Set(0)
	m.NextRate = value
}

// GetNextRate returns value of NextRate conditional field and
// boolean which is true if field was set.
func (m *MessagesMessagesSlice) GetNextRate() (value int, ok bool) {
	if !m.Flags.Has(0) {
		return value, false
	}
	return m.NextRate, true
}

// SetOffsetIDOffset sets value of OffsetIDOffset conditional field.
func (m *MessagesMessagesSlice) SetOffsetIDOffset(value int) {
	m.Flags.Set(2)
	m.OffsetIDOffset = value
}

// GetOffsetIDOffset returns value of OffsetIDOffset conditional field and
// boolean which is true if field was set.
func (m *MessagesMessagesSlice) GetOffsetIDOffset() (value int, ok bool) {
	if !m.Flags.Has(2) {
		return value, false
	}
	return m.OffsetIDOffset, true
}

// Decode implements bin.Decoder.
func (m *MessagesMessagesSlice) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messages.messagesSlice#3a54685e to nil")
	}
	if err := b.ConsumeID(MessagesMessagesSliceTypeID); err != nil {
		return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: %w", err)
	}
	{
		if err := m.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field flags: %w", err)
		}
	}
	m.Inexact = m.Flags.Has(1)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field count: %w", err)
		}
		m.Count = value
	}
	if m.Flags.Has(0) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field next_rate: %w", err)
		}
		m.NextRate = value
	}
	if m.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field offset_id_offset: %w", err)
		}
		m.OffsetIDOffset = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessage(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field messages: %w", err)
			}
			m.Messages = append(m.Messages, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field chats: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field chats: %w", err)
			}
			m.Chats = append(m.Chats, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field users: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.messagesSlice#3a54685e: field users: %w", err)
			}
			m.Users = append(m.Users, value)
		}
	}
	return nil
}

// construct implements constructor of MessagesMessagesClass.
func (m MessagesMessagesSlice) construct() MessagesMessagesClass { return &m }

// Ensuring interfaces in compile-time for MessagesMessagesSlice.
var (
	_ bin.Encoder = &MessagesMessagesSlice{}
	_ bin.Decoder = &MessagesMessagesSlice{}

	_ MessagesMessagesClass = &MessagesMessagesSlice{}
)

// MessagesChannelMessages represents TL type `messages.channelMessages#64479808`.
//
// See https://core.telegram.org/constructor/messages.channelMessages for reference.
type MessagesChannelMessages struct {
	// Flags field of MessagesChannelMessages.
	Flags bin.Fields
	// Inexact field of MessagesChannelMessages.
	Inexact bool
	// Pts field of MessagesChannelMessages.
	Pts int
	// Count field of MessagesChannelMessages.
	Count int
	// OffsetIDOffset field of MessagesChannelMessages.
	//
	// Use SetOffsetIDOffset and GetOffsetIDOffset helpers.
	OffsetIDOffset int
	// Messages field of MessagesChannelMessages.
	Messages []MessageClass
	// Chats field of MessagesChannelMessages.
	Chats []ChatClass
	// Users field of MessagesChannelMessages.
	Users []UserClass
}

// MessagesChannelMessagesTypeID is TL type id of MessagesChannelMessages.
const MessagesChannelMessagesTypeID = 0x64479808

// Encode implements bin.Encoder.
func (c *MessagesChannelMessages) Encode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't encode messages.channelMessages#64479808 as nil")
	}
	b.PutID(MessagesChannelMessagesTypeID)
	if err := c.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode messages.channelMessages#64479808: field flags: %w", err)
	}
	b.PutInt(c.Pts)
	b.PutInt(c.Count)
	if c.Flags.Has(2) {
		b.PutInt(c.OffsetIDOffset)
	}
	b.PutVectorHeader(len(c.Messages))
	for idx, v := range c.Messages {
		if v == nil {
			return fmt.Errorf("unable to encode messages.channelMessages#64479808: field messages element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.channelMessages#64479808: field messages element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(c.Chats))
	for idx, v := range c.Chats {
		if v == nil {
			return fmt.Errorf("unable to encode messages.channelMessages#64479808: field chats element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.channelMessages#64479808: field chats element with index %d: %w", idx, err)
		}
	}
	b.PutVectorHeader(len(c.Users))
	for idx, v := range c.Users {
		if v == nil {
			return fmt.Errorf("unable to encode messages.channelMessages#64479808: field users element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode messages.channelMessages#64479808: field users element with index %d: %w", idx, err)
		}
	}
	return nil
}

// SetInexact sets value of Inexact conditional field.
func (c *MessagesChannelMessages) SetInexact(value bool) {
	if value {
		c.Flags.Set(1)
	} else {
		c.Flags.Unset(1)
	}
}

// SetOffsetIDOffset sets value of OffsetIDOffset conditional field.
func (c *MessagesChannelMessages) SetOffsetIDOffset(value int) {
	c.Flags.Set(2)
	c.OffsetIDOffset = value
}

// GetOffsetIDOffset returns value of OffsetIDOffset conditional field and
// boolean which is true if field was set.
func (c *MessagesChannelMessages) GetOffsetIDOffset() (value int, ok bool) {
	if !c.Flags.Has(2) {
		return value, false
	}
	return c.OffsetIDOffset, true
}

// Decode implements bin.Decoder.
func (c *MessagesChannelMessages) Decode(b *bin.Buffer) error {
	if c == nil {
		return fmt.Errorf("can't decode messages.channelMessages#64479808 to nil")
	}
	if err := b.ConsumeID(MessagesChannelMessagesTypeID); err != nil {
		return fmt.Errorf("unable to decode messages.channelMessages#64479808: %w", err)
	}
	{
		if err := c.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field flags: %w", err)
		}
	}
	c.Inexact = c.Flags.Has(1)
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field pts: %w", err)
		}
		c.Pts = value
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field count: %w", err)
		}
		c.Count = value
	}
	if c.Flags.Has(2) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field offset_id_offset: %w", err)
		}
		c.OffsetIDOffset = value
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field messages: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeMessage(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.channelMessages#64479808: field messages: %w", err)
			}
			c.Messages = append(c.Messages, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field chats: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeChat(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.channelMessages#64479808: field chats: %w", err)
			}
			c.Chats = append(c.Chats, value)
		}
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode messages.channelMessages#64479808: field users: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeUser(b)
			if err != nil {
				return fmt.Errorf("unable to decode messages.channelMessages#64479808: field users: %w", err)
			}
			c.Users = append(c.Users, value)
		}
	}
	return nil
}

// construct implements constructor of MessagesMessagesClass.
func (c MessagesChannelMessages) construct() MessagesMessagesClass { return &c }

// Ensuring interfaces in compile-time for MessagesChannelMessages.
var (
	_ bin.Encoder = &MessagesChannelMessages{}
	_ bin.Decoder = &MessagesChannelMessages{}

	_ MessagesMessagesClass = &MessagesChannelMessages{}
)

// MessagesMessagesNotModified represents TL type `messages.messagesNotModified#74535f21`.
//
// See https://core.telegram.org/constructor/messages.messagesNotModified for reference.
type MessagesMessagesNotModified struct {
	// Count field of MessagesMessagesNotModified.
	Count int
}

// MessagesMessagesNotModifiedTypeID is TL type id of MessagesMessagesNotModified.
const MessagesMessagesNotModifiedTypeID = 0x74535f21

// Encode implements bin.Encoder.
func (m *MessagesMessagesNotModified) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode messages.messagesNotModified#74535f21 as nil")
	}
	b.PutID(MessagesMessagesNotModifiedTypeID)
	b.PutInt(m.Count)
	return nil
}

// Decode implements bin.Decoder.
func (m *MessagesMessagesNotModified) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode messages.messagesNotModified#74535f21 to nil")
	}
	if err := b.ConsumeID(MessagesMessagesNotModifiedTypeID); err != nil {
		return fmt.Errorf("unable to decode messages.messagesNotModified#74535f21: %w", err)
	}
	{
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode messages.messagesNotModified#74535f21: field count: %w", err)
		}
		m.Count = value
	}
	return nil
}

// construct implements constructor of MessagesMessagesClass.
func (m MessagesMessagesNotModified) construct() MessagesMessagesClass { return &m }

// Ensuring interfaces in compile-time for MessagesMessagesNotModified.
var (
	_ bin.Encoder = &MessagesMessagesNotModified{}
	_ bin.Decoder = &MessagesMessagesNotModified{}

	_ MessagesMessagesClass = &MessagesMessagesNotModified{}
)

// MessagesMessagesClass represents messages.Messages generic type.
//
// See https://core.telegram.org/type/messages.Messages for reference.
//
// Example:
//  g, err := DecodeMessagesMessages(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *MessagesMessages: // messages.messages#8c718e87
//  case *MessagesMessagesSlice: // messages.messagesSlice#3a54685e
//  case *MessagesChannelMessages: // messages.channelMessages#64479808
//  case *MessagesMessagesNotModified: // messages.messagesNotModified#74535f21
//  default: panic(v)
//  }
type MessagesMessagesClass interface {
	bin.Encoder
	bin.Decoder
	construct() MessagesMessagesClass
}

// DecodeMessagesMessages implements binary de-serialization for MessagesMessagesClass.
func DecodeMessagesMessages(buf *bin.Buffer) (MessagesMessagesClass, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case MessagesMessagesTypeID:
		// Decoding messages.messages#8c718e87.
		v := MessagesMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessagesMessagesClass: %w", err)
		}
		return &v, nil
	case MessagesMessagesSliceTypeID:
		// Decoding messages.messagesSlice#3a54685e.
		v := MessagesMessagesSlice{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessagesMessagesClass: %w", err)
		}
		return &v, nil
	case MessagesChannelMessagesTypeID:
		// Decoding messages.channelMessages#64479808.
		v := MessagesChannelMessages{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessagesMessagesClass: %w", err)
		}
		return &v, nil
	case MessagesMessagesNotModifiedTypeID:
		// Decoding messages.messagesNotModified#74535f21.
		v := MessagesMessagesNotModified{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode MessagesMessagesClass: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode MessagesMessagesClass: %w", bin.NewUnexpectedID(id))
	}
}

// MessagesMessages boxes the MessagesMessagesClass providing a helper.
type MessagesMessagesBox struct {
	Messages MessagesMessagesClass
}

// Decode implements bin.Decoder for MessagesMessagesBox.
func (b *MessagesMessagesBox) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("unable to decode MessagesMessagesBox to nil")
	}
	v, err := DecodeMessagesMessages(buf)
	if err != nil {
		return fmt.Errorf("unable to decode boxed value: %w", err)
	}
	b.Messages = v
	return nil
}

// Encode implements bin.Encode for MessagesMessagesBox.
func (b *MessagesMessagesBox) Encode(buf *bin.Buffer) error {
	if b == nil || b.Messages == nil {
		return fmt.Errorf("unable to encode MessagesMessagesClass as nil")
	}
	return b.Messages.Encode(buf)
}
