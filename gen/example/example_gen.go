// Code generated by gotdgen, DO NOT EDIT.

package td

import (
	"context"
	"fmt"

	"github.com/ernado/td/bin"
)

// No-op definition for keeping imports.
var _ = bin.Buffer{}

// Int32 represents TL type int32#5cb934fa.
type Int32 struct {
}

// Int32TypeID is TL type id of Int32.
const Int32TypeID = 0x5cb934fa

// Encode implements bin.Encoder.
func (i *Int32) Encode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't encode int32#5cb934fa as nil")
	}
	b.PutID(Int32TypeID)
	return nil
}

// Decode implements bin.Decoder.
func (i *Int32) Decode(b *bin.Buffer) error {
	if i == nil {
		return fmt.Errorf("can't decode int32#5cb934fa to nil")
	}
	if err := b.ConsumeID(Int32TypeID); err != nil {
		return fmt.Errorf("unable to decode int32#5cb934fa: %w", err)
	}
	return nil
}

// Ensuring interfaces in compile-time for Int32.
var (
	_ bin.Encoder = &Int32{}
	_ bin.Decoder = &Int32{}
)

// String represents TL type string#b5286e24.
type String struct {
}

// StringTypeID is TL type id of String.
const StringTypeID = 0xb5286e24

// Encode implements bin.Encoder.
func (s *String) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode string#b5286e24 as nil")
	}
	b.PutID(StringTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (s *String) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode string#b5286e24 to nil")
	}
	if err := b.ConsumeID(StringTypeID); err != nil {
		return fmt.Errorf("unable to decode string#b5286e24: %w", err)
	}
	return nil
}

// Ensuring interfaces in compile-time for String.
var (
	_ bin.Encoder = &String{}
	_ bin.Decoder = &String{}
)

// False represents TL type false#bc799737.
type False struct {
}

// FalseTypeID is TL type id of False.
const FalseTypeID = 0xbc799737

// Encode implements bin.Encoder.
func (f *False) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode false#bc799737 as nil")
	}
	b.PutID(FalseTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (f *False) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode false#bc799737 to nil")
	}
	if err := b.ConsumeID(FalseTypeID); err != nil {
		return fmt.Errorf("unable to decode false#bc799737: %w", err)
	}
	return nil
}

// construct implements constructor of Bool.
func (f False) construct() Bool { return &f }

// Ensuring interfaces in compile-time for False.
var (
	_ bin.Encoder = &False{}
	_ bin.Decoder = &False{}

	_ Bool = &False{}
)

// True represents TL type true#997275b5.
type True struct {
}

// TrueTypeID is TL type id of True.
const TrueTypeID = 0x997275b5

// Encode implements bin.Encoder.
func (t *True) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode true#997275b5 as nil")
	}
	b.PutID(TrueTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *True) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode true#997275b5 to nil")
	}
	if err := b.ConsumeID(TrueTypeID); err != nil {
		return fmt.Errorf("unable to decode true#997275b5: %w", err)
	}
	return nil
}

// construct implements constructor of Bool.
func (t True) construct() Bool { return &t }

// Ensuring interfaces in compile-time for True.
var (
	_ bin.Encoder = &True{}
	_ bin.Decoder = &True{}

	_ Bool = &True{}
)

// Bytes represents TL type bytes#e937bb82.
type Bytes struct {
}

// BytesTypeID is TL type id of Bytes.
const BytesTypeID = 0xe937bb82

// Encode implements bin.Encoder.
func (b *Bytes) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode bytes#e937bb82 as nil")
	}
	buf.PutID(BytesTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (b *Bytes) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode bytes#e937bb82 to nil")
	}
	if err := buf.ConsumeID(BytesTypeID); err != nil {
		return fmt.Errorf("unable to decode bytes#e937bb82: %w", err)
	}
	return nil
}

// Ensuring interfaces in compile-time for Bytes.
var (
	_ bin.Encoder = &Bytes{}
	_ bin.Decoder = &Bytes{}
)

// An object of this type can be returned on every function call, in case of an error
type Error struct {
	// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
	Code int32
	// Error message; subject to future changes
	Message string
	// Temporary field of Error.
	Temporary bool
}

// ErrorTypeID is TL type id of Error.
const ErrorTypeID = 0x14feebbc

// Encode implements bin.Encoder.
func (e *Error) Encode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't encode error#14feebbc as nil")
	}
	b.PutID(ErrorTypeID)
	b.PutInt32(e.Code)
	b.PutString(e.Message)
	b.PutBool(e.Temporary)
	return nil
}

// Decode implements bin.Decoder.
func (e *Error) Decode(b *bin.Buffer) error {
	if e == nil {
		return fmt.Errorf("can't decode error#14feebbc to nil")
	}
	if err := b.ConsumeID(ErrorTypeID); err != nil {
		return fmt.Errorf("unable to decode error#14feebbc: %w", err)
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode error#14feebbc: field code: %w", err)
		}
		e.Code = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode error#14feebbc: field message: %w", err)
		}
		e.Message = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode error#14feebbc: field temporary: %w", err)
		}
		e.Temporary = value
	}
	return nil
}

// Ensuring interfaces in compile-time for Error.
var (
	_ bin.Encoder = &Error{}
	_ bin.Decoder = &Error{}
)

// can be returned by functions as result.
type Ok struct {
}

// OkTypeID is TL type id of Ok.
const OkTypeID = 0xd4edbe69

// Encode implements bin.Encoder.
func (o *Ok) Encode(b *bin.Buffer) error {
	if o == nil {
		return fmt.Errorf("can't encode ok#d4edbe69 as nil")
	}
	b.PutID(OkTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (o *Ok) Decode(b *bin.Buffer) error {
	if o == nil {
		return fmt.Errorf("can't decode ok#d4edbe69 to nil")
	}
	if err := b.ConsumeID(OkTypeID); err != nil {
		return fmt.Errorf("unable to decode ok#d4edbe69: %w", err)
	}
	return nil
}

// Ensuring interfaces in compile-time for Ok.
var (
	_ bin.Encoder = &Ok{}
	_ bin.Decoder = &Ok{}
)

// Message represents TL type message#ec200d96.
type Message struct {
	// Err field of Message.
	Err Error
}

// MessageTypeID is TL type id of Message.
const MessageTypeID = 0xec200d96

// Encode implements bin.Encoder.
func (m *Message) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#ec200d96 as nil")
	}
	b.PutID(MessageTypeID)
	if err := m.Err.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#ec200d96: field err: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *Message) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#ec200d96 to nil")
	}
	if err := b.ConsumeID(MessageTypeID); err != nil {
		return fmt.Errorf("unable to decode message#ec200d96: %w", err)
	}
	{
		if err := m.Err.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#ec200d96: field err: %w", err)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for Message.
var (
	_ bin.Encoder = &Message{}
	_ bin.Decoder = &Message{}
)

// SMS represents TL type sms#ed8bebfe.
type SMS struct {
	// Text field of SMS.
	Text string
}

// SMSTypeID is TL type id of SMS.
const SMSTypeID = 0xed8bebfe

// Encode implements bin.Encoder.
func (s *SMS) Encode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't encode sms#ed8bebfe as nil")
	}
	b.PutID(SMSTypeID)
	b.PutString(s.Text)
	return nil
}

// Decode implements bin.Decoder.
func (s *SMS) Decode(b *bin.Buffer) error {
	if s == nil {
		return fmt.Errorf("can't decode sms#ed8bebfe to nil")
	}
	if err := b.ConsumeID(SMSTypeID); err != nil {
		return fmt.Errorf("unable to decode sms#ed8bebfe: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode sms#ed8bebfe: field text: %w", err)
		}
		s.Text = value
	}
	return nil
}

// Ensuring interfaces in compile-time for SMS.
var (
	_ bin.Encoder = &SMS{}
	_ bin.Decoder = &SMS{}
)

// ResponseID represents TL type responseID#85d7fd8b.
type ResponseID struct {
	// ID field of ResponseID.
	ID int32
}

// ResponseIDTypeID is TL type id of ResponseID.
const ResponseIDTypeID = 0x85d7fd8b

// Encode implements bin.Encoder.
func (r *ResponseID) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode responseID#85d7fd8b as nil")
	}
	b.PutID(ResponseIDTypeID)
	b.PutInt32(r.ID)
	return nil
}

// Decode implements bin.Decoder.
func (r *ResponseID) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode responseID#85d7fd8b to nil")
	}
	if err := b.ConsumeID(ResponseIDTypeID); err != nil {
		return fmt.Errorf("unable to decode responseID#85d7fd8b: %w", err)
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode responseID#85d7fd8b: field id: %w", err)
		}
		r.ID = value
	}
	return nil
}

// construct implements constructor of Response.
func (r ResponseID) construct() Response { return &r }

// Ensuring interfaces in compile-time for ResponseID.
var (
	_ bin.Encoder = &ResponseID{}
	_ bin.Decoder = &ResponseID{}

	_ Response = &ResponseID{}
)

// ResponseText represents TL type responseText#cb0244f2.
type ResponseText struct {
	// Text field of ResponseText.
	Text string
}

// ResponseTextTypeID is TL type id of ResponseText.
const ResponseTextTypeID = 0xcb0244f2

// Encode implements bin.Encoder.
func (r *ResponseText) Encode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't encode responseText#cb0244f2 as nil")
	}
	b.PutID(ResponseTextTypeID)
	b.PutString(r.Text)
	return nil
}

// Decode implements bin.Decoder.
func (r *ResponseText) Decode(b *bin.Buffer) error {
	if r == nil {
		return fmt.Errorf("can't decode responseText#cb0244f2 to nil")
	}
	if err := b.ConsumeID(ResponseTextTypeID); err != nil {
		return fmt.Errorf("unable to decode responseText#cb0244f2: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode responseText#cb0244f2: field text: %w", err)
		}
		r.Text = value
	}
	return nil
}

// construct implements constructor of Response.
func (r ResponseText) construct() Response { return &r }

// Ensuring interfaces in compile-time for ResponseText.
var (
	_ bin.Encoder = &ResponseText{}
	_ bin.Decoder = &ResponseText{}

	_ Response = &ResponseText{}
)

// Message
type BigMessage struct {
	// ID field of BigMessage.
	ID int32
	// Count field of BigMessage.
	Count int32
	// TargetId field of BigMessage.
	TargetId int32
	// Escape field of BigMessage.
	Escape bool
	// Summary field of BigMessage.
	Summary bool
}

// BigMessageTypeID is TL type id of BigMessage.
const BigMessageTypeID = 0x7490dcc5

// Encode implements bin.Encoder.
func (b *BigMessage) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode bigMessage#7490dcc5 as nil")
	}
	buf.PutID(BigMessageTypeID)
	buf.PutInt32(b.ID)
	buf.PutInt32(b.Count)
	buf.PutInt32(b.TargetId)
	buf.PutBool(b.Escape)
	buf.PutBool(b.Summary)
	return nil
}

// Decode implements bin.Decoder.
func (b *BigMessage) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode bigMessage#7490dcc5 to nil")
	}
	if err := buf.ConsumeID(BigMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode bigMessage#7490dcc5: %w", err)
	}
	{
		value, err := buf.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode bigMessage#7490dcc5: field id: %w", err)
		}
		b.ID = value
	}
	{
		value, err := buf.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode bigMessage#7490dcc5: field count: %w", err)
		}
		b.Count = value
	}
	{
		value, err := buf.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode bigMessage#7490dcc5: field targetId: %w", err)
		}
		b.TargetId = value
	}
	{
		value, err := buf.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode bigMessage#7490dcc5: field escape: %w", err)
		}
		b.Escape = value
	}
	{
		value, err := buf.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode bigMessage#7490dcc5: field summary: %w", err)
		}
		b.Summary = value
	}
	return nil
}

// construct implements constructor of AbstractMessage.
func (b BigMessage) construct() AbstractMessage { return &b }

// Ensuring interfaces in compile-time for BigMessage.
var (
	_ bin.Encoder = &BigMessage{}
	_ bin.Decoder = &BigMessage{}

	_ AbstractMessage = &BigMessage{}
)

// NoMessage represents TL type noMessage#ee6324c4.
type NoMessage struct {
}

// NoMessageTypeID is TL type id of NoMessage.
const NoMessageTypeID = 0xee6324c4

// Encode implements bin.Encoder.
func (n *NoMessage) Encode(b *bin.Buffer) error {
	if n == nil {
		return fmt.Errorf("can't encode noMessage#ee6324c4 as nil")
	}
	b.PutID(NoMessageTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (n *NoMessage) Decode(b *bin.Buffer) error {
	if n == nil {
		return fmt.Errorf("can't decode noMessage#ee6324c4 to nil")
	}
	if err := b.ConsumeID(NoMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode noMessage#ee6324c4: %w", err)
	}
	return nil
}

// construct implements constructor of AbstractMessage.
func (n NoMessage) construct() AbstractMessage { return &n }

// Ensuring interfaces in compile-time for NoMessage.
var (
	_ bin.Encoder = &NoMessage{}
	_ bin.Decoder = &NoMessage{}

	_ AbstractMessage = &NoMessage{}
)

// TargetsMessage represents TL type targetsMessage#cc6136f1.
type TargetsMessage struct {
	// Targets field of TargetsMessage.
	Targets []int32
}

// TargetsMessageTypeID is TL type id of TargetsMessage.
const TargetsMessageTypeID = 0xcc6136f1

// Encode implements bin.Encoder.
func (t *TargetsMessage) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode targetsMessage#cc6136f1 as nil")
	}
	b.PutID(TargetsMessageTypeID)
	b.PutVectorHeader(len(t.Targets))
	for _, v := range t.Targets {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TargetsMessage) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode targetsMessage#cc6136f1 to nil")
	}
	if err := b.ConsumeID(TargetsMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode targetsMessage#cc6136f1: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode targetsMessage#cc6136f1: field targets: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode targetsMessage#cc6136f1: field targets: %w", err)
			}
			t.Targets = append(t.Targets, value)
		}
	}
	return nil
}

// construct implements constructor of AbstractMessage.
func (t TargetsMessage) construct() AbstractMessage { return &t }

// Ensuring interfaces in compile-time for TargetsMessage.
var (
	_ bin.Encoder = &TargetsMessage{}
	_ bin.Decoder = &TargetsMessage{}

	_ AbstractMessage = &TargetsMessage{}
)

// Update represents TL type update#b03e2ef8.
type Update struct {
	// Msg field of Update.
	Msg AbstractMessage
	// Delay field of Update.
	Delay int32
}

// UpdateTypeID is TL type id of Update.
const UpdateTypeID = 0xb03e2ef8

// Encode implements bin.Encoder.
func (u *Update) Encode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't encode update#b03e2ef8 as nil")
	}
	b.PutID(UpdateTypeID)
	if u.Msg == nil {
		return fmt.Errorf("unable to encode update#b03e2ef8: field msg is nil")
	}
	if err := u.Msg.Encode(b); err != nil {
		return fmt.Errorf("unable to encode update#b03e2ef8: field msg: %w", err)
	}
	b.PutInt32(u.Delay)
	return nil
}

// Decode implements bin.Decoder.
func (u *Update) Decode(b *bin.Buffer) error {
	if u == nil {
		return fmt.Errorf("can't decode update#b03e2ef8 to nil")
	}
	if err := b.ConsumeID(UpdateTypeID); err != nil {
		return fmt.Errorf("unable to decode update#b03e2ef8: %w", err)
	}
	{
		value, err := DecodeAbstractMessage(b)
		if err != nil {
			return fmt.Errorf("unable to decode update#b03e2ef8: field msg: %w", err)
		}
		u.Msg = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode update#b03e2ef8: field delay: %w", err)
		}
		u.Delay = value
	}
	return nil
}

// Ensuring interfaces in compile-time for Update.
var (
	_ bin.Encoder = &Update{}
	_ bin.Decoder = &Update{}
)

// GetUpdatesResp represents TL type getUpdatesResp#2b4b45c.
type GetUpdatesResp struct {
	// Updates field of GetUpdatesResp.
	Updates []AbstractMessage
}

// GetUpdatesRespTypeID is TL type id of GetUpdatesResp.
const GetUpdatesRespTypeID = 0x2b4b45c

// Encode implements bin.Encoder.
func (g *GetUpdatesResp) Encode(b *bin.Buffer) error {
	if g == nil {
		return fmt.Errorf("can't encode getUpdatesResp#2b4b45c as nil")
	}
	b.PutID(GetUpdatesRespTypeID)
	b.PutVectorHeader(len(g.Updates))
	for idx, v := range g.Updates {
		if v == nil {
			return fmt.Errorf("unable to encode getUpdatesResp#2b4b45c: field updates element with index %d is nil", idx)
		}
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode getUpdatesResp#2b4b45c: field updates element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (g *GetUpdatesResp) Decode(b *bin.Buffer) error {
	if g == nil {
		return fmt.Errorf("can't decode getUpdatesResp#2b4b45c to nil")
	}
	if err := b.ConsumeID(GetUpdatesRespTypeID); err != nil {
		return fmt.Errorf("unable to decode getUpdatesResp#2b4b45c: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode getUpdatesResp#2b4b45c: field updates: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := DecodeAbstractMessage(b)
			if err != nil {
				return fmt.Errorf("unable to decode getUpdatesResp#2b4b45c: field updates: %w", err)
			}
			g.Updates = append(g.Updates, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for GetUpdatesResp.
var (
	_ bin.Encoder = &GetUpdatesResp{}
	_ bin.Decoder = &GetUpdatesResp{}
)

// FieldsMessage represents TL type fieldsMessage#947225b5.
type FieldsMessage struct {
	// Flags field of FieldsMessage.
	Flags bin.Fields
	// Escape field of FieldsMessage.
	Escape bool
	// TTLSeconds field of FieldsMessage.
	//
	// Use SetTTLSeconds and GetTTLSeconds helpers.
	TTLSeconds int
}

// FieldsMessageTypeID is TL type id of FieldsMessage.
const FieldsMessageTypeID = 0x947225b5

// Encode implements bin.Encoder.
func (f *FieldsMessage) Encode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't encode fieldsMessage#947225b5 as nil")
	}
	b.PutID(FieldsMessageTypeID)
	if err := f.Flags.Encode(b); err != nil {
		return fmt.Errorf("unable to encode fieldsMessage#947225b5: field flags: %w", err)
	}
	if f.Flags.Has(1) {
		b.PutInt(f.TTLSeconds)
	}
	return nil
}

// SetEscape sets value of Escape conditional field.
func (f *FieldsMessage) SetEscape(value bool) {
	if value {
		f.Flags.Set(0)
	} else {
		f.Flags.Unset(0)
	}
}

// SetTTLSeconds sets value of TTLSeconds conditional field.
func (f *FieldsMessage) SetTTLSeconds(value int) {
	f.Flags.Set(1)
	f.TTLSeconds = value
}

// GetTTLSeconds returns value of TTLSeconds conditional field and
// boolean which is true if field was set.
func (f *FieldsMessage) GetTTLSeconds() (value int, ok bool) {
	if !f.Flags.Has(1) {
		return value, false
	}
	return f.TTLSeconds, true
}

// Decode implements bin.Decoder.
func (f *FieldsMessage) Decode(b *bin.Buffer) error {
	if f == nil {
		return fmt.Errorf("can't decode fieldsMessage#947225b5 to nil")
	}
	if err := b.ConsumeID(FieldsMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode fieldsMessage#947225b5: %w", err)
	}
	{
		if err := f.Flags.Decode(b); err != nil {
			return fmt.Errorf("unable to decode fieldsMessage#947225b5: field flags: %w", err)
		}
	}
	f.Escape = f.Flags.Has(0)
	if f.Flags.Has(1) {
		value, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode fieldsMessage#947225b5: field ttl_seconds: %w", err)
		}
		f.TTLSeconds = value
	}
	return nil
}

// construct implements constructor of AbstractMessage.
func (f FieldsMessage) construct() AbstractMessage { return &f }

// Ensuring interfaces in compile-time for FieldsMessage.
var (
	_ bin.Encoder = &FieldsMessage{}
	_ bin.Decoder = &FieldsMessage{}

	_ AbstractMessage = &FieldsMessage{}
)

// BytesMessage represents TL type bytesMessage#f990a67d.
type BytesMessage struct {
	// Data field of BytesMessage.
	Data []byte
}

// BytesMessageTypeID is TL type id of BytesMessage.
const BytesMessageTypeID = 0xf990a67d

// Encode implements bin.Encoder.
func (b *BytesMessage) Encode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't encode bytesMessage#f990a67d as nil")
	}
	buf.PutID(BytesMessageTypeID)
	buf.PutBytes(b.Data)
	return nil
}

// Decode implements bin.Decoder.
func (b *BytesMessage) Decode(buf *bin.Buffer) error {
	if b == nil {
		return fmt.Errorf("can't decode bytesMessage#f990a67d to nil")
	}
	if err := buf.ConsumeID(BytesMessageTypeID); err != nil {
		return fmt.Errorf("unable to decode bytesMessage#f990a67d: %w", err)
	}
	{
		value, err := buf.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode bytesMessage#f990a67d: field data: %w", err)
		}
		b.Data = value
	}
	return nil
}

// construct implements constructor of AbstractMessage.
func (b BytesMessage) construct() AbstractMessage { return &b }

// Ensuring interfaces in compile-time for BytesMessage.
var (
	_ bin.Encoder = &BytesMessage{}
	_ bin.Decoder = &BytesMessage{}

	_ AbstractMessage = &BytesMessage{}
)

// A mention of a user by their username
type TextEntityTypeMention struct {
}

// TextEntityTypeMentionTypeID is TL type id of TextEntityTypeMention.
const TextEntityTypeMentionTypeID = 0x37b3df65

// Encode implements bin.Encoder.
func (t *TextEntityTypeMention) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMention#37b3df65 as nil")
	}
	b.PutID(TextEntityTypeMentionTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeMention) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMention#37b3df65 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeMentionTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeMention#37b3df65: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeMention) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeMention.
var (
	_ bin.Encoder = &TextEntityTypeMention{}
	_ bin.Decoder = &TextEntityTypeMention{}

	_ TextEntityType = &TextEntityTypeMention{}
)

// A hashtag text, beginning with "#"
type TextEntityTypeHashtag struct {
}

// TextEntityTypeHashtagTypeID is TL type id of TextEntityTypeHashtag.
const TextEntityTypeHashtagTypeID = 0xc2f7a2dd

// Encode implements bin.Encoder.
func (t *TextEntityTypeHashtag) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeHashtag#c2f7a2dd as nil")
	}
	b.PutID(TextEntityTypeHashtagTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeHashtag) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeHashtag#c2f7a2dd to nil")
	}
	if err := b.ConsumeID(TextEntityTypeHashtagTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeHashtag#c2f7a2dd: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeHashtag) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeHashtag.
var (
	_ bin.Encoder = &TextEntityTypeHashtag{}
	_ bin.Decoder = &TextEntityTypeHashtag{}

	_ TextEntityType = &TextEntityTypeHashtag{}
)

// A cashtag text, beginning with "$" and consisting of capital english letters (i.e. "$USD")
type TextEntityTypeCashtag struct {
}

// TextEntityTypeCashtagTypeID is TL type id of TextEntityTypeCashtag.
const TextEntityTypeCashtagTypeID = 0x48e4374b

// Encode implements bin.Encoder.
func (t *TextEntityTypeCashtag) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCashtag#48e4374b as nil")
	}
	b.PutID(TextEntityTypeCashtagTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeCashtag) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCashtag#48e4374b to nil")
	}
	if err := b.ConsumeID(TextEntityTypeCashtagTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeCashtag#48e4374b: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeCashtag) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeCashtag.
var (
	_ bin.Encoder = &TextEntityTypeCashtag{}
	_ bin.Decoder = &TextEntityTypeCashtag{}

	_ TextEntityType = &TextEntityTypeCashtag{}
)

// A bot command, beginning with "/". This shouldn't be highlighted if there are no bots in the chat
type TextEntityTypeBotCommand struct {
}

// TextEntityTypeBotCommandTypeID is TL type id of TextEntityTypeBotCommand.
const TextEntityTypeBotCommandTypeID = 0xbb652bb3

// Encode implements bin.Encoder.
func (t *TextEntityTypeBotCommand) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBotCommand#bb652bb3 as nil")
	}
	b.PutID(TextEntityTypeBotCommandTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBotCommand) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBotCommand#bb652bb3 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBotCommandTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBotCommand#bb652bb3: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeBotCommand) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBotCommand.
var (
	_ bin.Encoder = &TextEntityTypeBotCommand{}
	_ bin.Decoder = &TextEntityTypeBotCommand{}

	_ TextEntityType = &TextEntityTypeBotCommand{}
)

// An HTTP URL
type TextEntityTypeUrl struct {
}

// TextEntityTypeUrlTypeID is TL type id of TextEntityTypeUrl.
const TextEntityTypeUrlTypeID = 0xb1c0d47c

// Encode implements bin.Encoder.
func (t *TextEntityTypeUrl) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUrl#b1c0d47c as nil")
	}
	b.PutID(TextEntityTypeUrlTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeUrl) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUrl#b1c0d47c to nil")
	}
	if err := b.ConsumeID(TextEntityTypeUrlTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeUrl#b1c0d47c: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeUrl) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeUrl.
var (
	_ bin.Encoder = &TextEntityTypeUrl{}
	_ bin.Decoder = &TextEntityTypeUrl{}

	_ TextEntityType = &TextEntityTypeUrl{}
)

// An email address
type TextEntityTypeEmailAddress struct {
}

// TextEntityTypeEmailAddressTypeID is TL type id of TextEntityTypeEmailAddress.
const TextEntityTypeEmailAddressTypeID = 0x54f81821

// Encode implements bin.Encoder.
func (t *TextEntityTypeEmailAddress) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeEmailAddress#54f81821 as nil")
	}
	b.PutID(TextEntityTypeEmailAddressTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeEmailAddress) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeEmailAddress#54f81821 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeEmailAddressTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeEmailAddress#54f81821: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeEmailAddress) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeEmailAddress.
var (
	_ bin.Encoder = &TextEntityTypeEmailAddress{}
	_ bin.Decoder = &TextEntityTypeEmailAddress{}

	_ TextEntityType = &TextEntityTypeEmailAddress{}
)

// A phone number
type TextEntityTypePhoneNumber struct {
}

// TextEntityTypePhoneNumberTypeID is TL type id of TextEntityTypePhoneNumber.
const TextEntityTypePhoneNumberTypeID = 0xbad9aa2a

// Encode implements bin.Encoder.
func (t *TextEntityTypePhoneNumber) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePhoneNumber#bad9aa2a as nil")
	}
	b.PutID(TextEntityTypePhoneNumberTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypePhoneNumber) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePhoneNumber#bad9aa2a to nil")
	}
	if err := b.ConsumeID(TextEntityTypePhoneNumberTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypePhoneNumber#bad9aa2a: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypePhoneNumber) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypePhoneNumber.
var (
	_ bin.Encoder = &TextEntityTypePhoneNumber{}
	_ bin.Decoder = &TextEntityTypePhoneNumber{}

	_ TextEntityType = &TextEntityTypePhoneNumber{}
)

// A bank card number. The getBankCardInfo method can be used to get information about the bank card
type TextEntityTypeBankCardNumber struct {
}

// TextEntityTypeBankCardNumberTypeID is TL type id of TextEntityTypeBankCardNumber.
const TextEntityTypeBankCardNumberTypeID = 0x6513910

// Encode implements bin.Encoder.
func (t *TextEntityTypeBankCardNumber) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBankCardNumber#6513910 as nil")
	}
	b.PutID(TextEntityTypeBankCardNumberTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBankCardNumber) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBankCardNumber#6513910 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBankCardNumberTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBankCardNumber#6513910: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeBankCardNumber) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBankCardNumber.
var (
	_ bin.Encoder = &TextEntityTypeBankCardNumber{}
	_ bin.Decoder = &TextEntityTypeBankCardNumber{}

	_ TextEntityType = &TextEntityTypeBankCardNumber{}
)

// A bold text
type TextEntityTypeBold struct {
}

// TextEntityTypeBoldTypeID is TL type id of TextEntityTypeBold.
const TextEntityTypeBoldTypeID = 0xbcc0e1b0

// Encode implements bin.Encoder.
func (t *TextEntityTypeBold) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeBold#bcc0e1b0 as nil")
	}
	b.PutID(TextEntityTypeBoldTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeBold) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeBold#bcc0e1b0 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeBoldTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeBold#bcc0e1b0: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeBold) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeBold.
var (
	_ bin.Encoder = &TextEntityTypeBold{}
	_ bin.Decoder = &TextEntityTypeBold{}

	_ TextEntityType = &TextEntityTypeBold{}
)

// An italic text
type TextEntityTypeItalic struct {
}

// TextEntityTypeItalicTypeID is TL type id of TextEntityTypeItalic.
const TextEntityTypeItalicTypeID = 0xf8f3965d

// Encode implements bin.Encoder.
func (t *TextEntityTypeItalic) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeItalic#f8f3965d as nil")
	}
	b.PutID(TextEntityTypeItalicTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeItalic) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeItalic#f8f3965d to nil")
	}
	if err := b.ConsumeID(TextEntityTypeItalicTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeItalic#f8f3965d: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeItalic) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeItalic.
var (
	_ bin.Encoder = &TextEntityTypeItalic{}
	_ bin.Decoder = &TextEntityTypeItalic{}

	_ TextEntityType = &TextEntityTypeItalic{}
)

// An underlined text
type TextEntityTypeUnderline struct {
}

// TextEntityTypeUnderlineTypeID is TL type id of TextEntityTypeUnderline.
const TextEntityTypeUnderlineTypeID = 0x2f39cf92

// Encode implements bin.Encoder.
func (t *TextEntityTypeUnderline) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeUnderline#2f39cf92 as nil")
	}
	b.PutID(TextEntityTypeUnderlineTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeUnderline) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeUnderline#2f39cf92 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeUnderlineTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeUnderline#2f39cf92: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeUnderline) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeUnderline.
var (
	_ bin.Encoder = &TextEntityTypeUnderline{}
	_ bin.Decoder = &TextEntityTypeUnderline{}

	_ TextEntityType = &TextEntityTypeUnderline{}
)

// A strikethrough text
type TextEntityTypeStrikethrough struct {
}

// TextEntityTypeStrikethroughTypeID is TL type id of TextEntityTypeStrikethrough.
const TextEntityTypeStrikethroughTypeID = 0x394fc4fa

// Encode implements bin.Encoder.
func (t *TextEntityTypeStrikethrough) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeStrikethrough#394fc4fa as nil")
	}
	b.PutID(TextEntityTypeStrikethroughTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeStrikethrough) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeStrikethrough#394fc4fa to nil")
	}
	if err := b.ConsumeID(TextEntityTypeStrikethroughTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeStrikethrough#394fc4fa: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeStrikethrough) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeStrikethrough.
var (
	_ bin.Encoder = &TextEntityTypeStrikethrough{}
	_ bin.Decoder = &TextEntityTypeStrikethrough{}

	_ TextEntityType = &TextEntityTypeStrikethrough{}
)

// Text that must be formatted as if inside a code HTML tag
type TextEntityTypeCode struct {
}

// TextEntityTypeCodeTypeID is TL type id of TextEntityTypeCode.
const TextEntityTypeCodeTypeID = 0xc5e9c94a

// Encode implements bin.Encoder.
func (t *TextEntityTypeCode) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeCode#c5e9c94a as nil")
	}
	b.PutID(TextEntityTypeCodeTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeCode) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeCode#c5e9c94a to nil")
	}
	if err := b.ConsumeID(TextEntityTypeCodeTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeCode#c5e9c94a: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeCode) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeCode.
var (
	_ bin.Encoder = &TextEntityTypeCode{}
	_ bin.Decoder = &TextEntityTypeCode{}

	_ TextEntityType = &TextEntityTypeCode{}
)

// Text that must be formatted as if inside a pre HTML tag
type TextEntityTypePre struct {
}

// TextEntityTypePreTypeID is TL type id of TextEntityTypePre.
const TextEntityTypePreTypeID = 0x62491c8e

// Encode implements bin.Encoder.
func (t *TextEntityTypePre) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePre#62491c8e as nil")
	}
	b.PutID(TextEntityTypePreTypeID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypePre) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePre#62491c8e to nil")
	}
	if err := b.ConsumeID(TextEntityTypePreTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypePre#62491c8e: %w", err)
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypePre) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypePre.
var (
	_ bin.Encoder = &TextEntityTypePre{}
	_ bin.Decoder = &TextEntityTypePre{}

	_ TextEntityType = &TextEntityTypePre{}
)

// Text that must be formatted as if inside pre, and code HTML tags
type TextEntityTypePreCode struct {
	// Programming language of the code; as defined by the sender
	Language string
}

// TextEntityTypePreCodeTypeID is TL type id of TextEntityTypePreCode.
const TextEntityTypePreCodeTypeID = 0xc7a77aab

// Encode implements bin.Encoder.
func (t *TextEntityTypePreCode) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypePreCode#c7a77aab as nil")
	}
	b.PutID(TextEntityTypePreCodeTypeID)
	b.PutString(t.Language)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypePreCode) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypePreCode#c7a77aab to nil")
	}
	if err := b.ConsumeID(TextEntityTypePreCodeTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypePreCode#c7a77aab: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypePreCode#c7a77aab: field language: %w", err)
		}
		t.Language = value
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypePreCode) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypePreCode.
var (
	_ bin.Encoder = &TextEntityTypePreCode{}
	_ bin.Decoder = &TextEntityTypePreCode{}

	_ TextEntityType = &TextEntityTypePreCode{}
)

// A text description shown instead of a raw URL
type TextEntityTypeTextUrl struct {
	// HTTP or tg:// URL to be opened when the link is clicked
	URL string
}

// TextEntityTypeTextUrlTypeID is TL type id of TextEntityTypeTextUrl.
const TextEntityTypeTextUrlTypeID = 0x1a912463

// Encode implements bin.Encoder.
func (t *TextEntityTypeTextUrl) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeTextUrl#1a912463 as nil")
	}
	b.PutID(TextEntityTypeTextUrlTypeID)
	b.PutString(t.URL)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeTextUrl) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeTextUrl#1a912463 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeTextUrlTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeTextUrl#1a912463: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypeTextUrl#1a912463: field url: %w", err)
		}
		t.URL = value
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeTextUrl) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeTextUrl.
var (
	_ bin.Encoder = &TextEntityTypeTextUrl{}
	_ bin.Decoder = &TextEntityTypeTextUrl{}

	_ TextEntityType = &TextEntityTypeTextUrl{}
)

// A text shows instead of a raw mention of the user (e.g., when the user has no username)
type TextEntityTypeMentionName struct {
	// Identifier of the mentioned user
	UserID int32
}

// TextEntityTypeMentionNameTypeID is TL type id of TextEntityTypeMentionName.
const TextEntityTypeMentionNameTypeID = 0xd0d2685d

// Encode implements bin.Encoder.
func (t *TextEntityTypeMentionName) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntityTypeMentionName#d0d2685d as nil")
	}
	b.PutID(TextEntityTypeMentionNameTypeID)
	b.PutInt32(t.UserID)
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntityTypeMentionName) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntityTypeMentionName#d0d2685d to nil")
	}
	if err := b.ConsumeID(TextEntityTypeMentionNameTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntityTypeMentionName#d0d2685d: %w", err)
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode textEntityTypeMentionName#d0d2685d: field user_id: %w", err)
		}
		t.UserID = value
	}
	return nil
}

// construct implements constructor of TextEntityType.
func (t TextEntityTypeMentionName) construct() TextEntityType { return &t }

// Ensuring interfaces in compile-time for TextEntityTypeMentionName.
var (
	_ bin.Encoder = &TextEntityTypeMentionName{}
	_ bin.Decoder = &TextEntityTypeMentionName{}

	_ TextEntityType = &TextEntityTypeMentionName{}
)

// Represents a part of the text that needs to be formatted in some unusual way
type TextEntity struct {
	// Offset of the entity, in UTF-16 code units
	Offset int32
	// Length of the entity, in UTF-16 code units
	Length int32
	// Type of the entity
	Type TextEntityType
}

// TextEntityTypeID is TL type id of TextEntity.
const TextEntityTypeID = 0x8bab99a8

// Encode implements bin.Encoder.
func (t *TextEntity) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntity#8bab99a8 as nil")
	}
	b.PutID(TextEntityTypeID)
	b.PutInt32(t.Offset)
	b.PutInt32(t.Length)
	if t.Type == nil {
		return fmt.Errorf("unable to encode textEntity#8bab99a8: field type is nil")
	}
	if err := t.Type.Encode(b); err != nil {
		return fmt.Errorf("unable to encode textEntity#8bab99a8: field type: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntity) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntity#8bab99a8 to nil")
	}
	if err := b.ConsumeID(TextEntityTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntity#8bab99a8: %w", err)
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode textEntity#8bab99a8: field offset: %w", err)
		}
		t.Offset = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode textEntity#8bab99a8: field length: %w", err)
		}
		t.Length = value
	}
	{
		value, err := DecodeTextEntityType(b)
		if err != nil {
			return fmt.Errorf("unable to decode textEntity#8bab99a8: field type: %w", err)
		}
		t.Type = value
	}
	return nil
}

// Ensuring interfaces in compile-time for TextEntity.
var (
	_ bin.Encoder = &TextEntity{}
	_ bin.Decoder = &TextEntity{}
)

// Contains a list of text entities
type TextEntities struct {
	// List of text entities
	Entities []TextEntity
}

// TextEntitiesTypeID is TL type id of TextEntities.
const TextEntitiesTypeID = 0xcf89c258

// Encode implements bin.Encoder.
func (t *TextEntities) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode textEntities#cf89c258 as nil")
	}
	b.PutID(TextEntitiesTypeID)
	b.PutVectorHeader(len(t.Entities))
	for idx, v := range t.Entities {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode textEntities#cf89c258: field entities element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TextEntities) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode textEntities#cf89c258 to nil")
	}
	if err := b.ConsumeID(TextEntitiesTypeID); err != nil {
		return fmt.Errorf("unable to decode textEntities#cf89c258: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode textEntities#cf89c258: field entities: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value TextEntity
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode textEntities#cf89c258: field entities: %w", err)
			}
			t.Entities = append(t.Entities, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TextEntities.
var (
	_ bin.Encoder = &TextEntities{}
	_ bin.Decoder = &TextEntities{}
)

// A simple object containing a number; for testing only
type TestInt struct {
	// Number
	Value int32
}

// TestIntTypeID is TL type id of TestInt.
const TestIntTypeID = 0xddbd2c09

// Encode implements bin.Encoder.
func (t *TestInt) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testInt#ddbd2c09 as nil")
	}
	b.PutID(TestIntTypeID)
	b.PutInt32(t.Value)
	return nil
}

// Decode implements bin.Decoder.
func (t *TestInt) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testInt#ddbd2c09 to nil")
	}
	if err := b.ConsumeID(TestIntTypeID); err != nil {
		return fmt.Errorf("unable to decode testInt#ddbd2c09: %w", err)
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode testInt#ddbd2c09: field value: %w", err)
		}
		t.Value = value
	}
	return nil
}

// Ensuring interfaces in compile-time for TestInt.
var (
	_ bin.Encoder = &TestInt{}
	_ bin.Decoder = &TestInt{}
)

// A simple object containing a string; for testing only
type TestString struct {
	// String
	Value string
}

// TestStringTypeID is TL type id of TestString.
const TestStringTypeID = 0xfe56688c

// Encode implements bin.Encoder.
func (t *TestString) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testString#fe56688c as nil")
	}
	b.PutID(TestStringTypeID)
	b.PutString(t.Value)
	return nil
}

// Decode implements bin.Decoder.
func (t *TestString) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testString#fe56688c to nil")
	}
	if err := b.ConsumeID(TestStringTypeID); err != nil {
		return fmt.Errorf("unable to decode testString#fe56688c: %w", err)
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode testString#fe56688c: field value: %w", err)
		}
		t.Value = value
	}
	return nil
}

// Ensuring interfaces in compile-time for TestString.
var (
	_ bin.Encoder = &TestString{}
	_ bin.Decoder = &TestString{}
)

// A simple object containing a sequence of bytes; for testing only
type TestBytes struct {
	// Bytes
	Value []byte
}

// TestBytesTypeID is TL type id of TestBytes.
const TestBytesTypeID = 0xa422c4de

// Encode implements bin.Encoder.
func (t *TestBytes) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testBytes#a422c4de as nil")
	}
	b.PutID(TestBytesTypeID)
	b.PutBytes(t.Value)
	return nil
}

// Decode implements bin.Decoder.
func (t *TestBytes) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testBytes#a422c4de to nil")
	}
	if err := b.ConsumeID(TestBytesTypeID); err != nil {
		return fmt.Errorf("unable to decode testBytes#a422c4de: %w", err)
	}
	{
		value, err := b.Bytes()
		if err != nil {
			return fmt.Errorf("unable to decode testBytes#a422c4de: field value: %w", err)
		}
		t.Value = value
	}
	return nil
}

// Ensuring interfaces in compile-time for TestBytes.
var (
	_ bin.Encoder = &TestBytes{}
	_ bin.Decoder = &TestBytes{}
)

// A simple object containing a vector of numbers; for testing only
type TestVectorInt struct {
	// Vector of numbers
	Value []int32
}

// TestVectorIntTypeID is TL type id of TestVectorInt.
const TestVectorIntTypeID = 0xdf9eb113

// Encode implements bin.Encoder.
func (t *TestVectorInt) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testVectorInt#df9eb113 as nil")
	}
	b.PutID(TestVectorIntTypeID)
	b.PutVectorHeader(len(t.Value))
	for _, v := range t.Value {
		b.PutInt32(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TestVectorInt) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testVectorInt#df9eb113 to nil")
	}
	if err := b.ConsumeID(TestVectorIntTypeID); err != nil {
		return fmt.Errorf("unable to decode testVectorInt#df9eb113: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode testVectorInt#df9eb113: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode testVectorInt#df9eb113: field value: %w", err)
			}
			t.Value = append(t.Value, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TestVectorInt.
var (
	_ bin.Encoder = &TestVectorInt{}
	_ bin.Decoder = &TestVectorInt{}
)

// A simple object containing a vector of objects that hold a number; for testing only
type TestVectorIntObject struct {
	// Vector of objects
	Value []TestInt
}

// TestVectorIntObjectTypeID is TL type id of TestVectorIntObject.
const TestVectorIntObjectTypeID = 0xf152999b

// Encode implements bin.Encoder.
func (t *TestVectorIntObject) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testVectorIntObject#f152999b as nil")
	}
	b.PutID(TestVectorIntObjectTypeID)
	b.PutVectorHeader(len(t.Value))
	for idx, v := range t.Value {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode testVectorIntObject#f152999b: field value element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TestVectorIntObject) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testVectorIntObject#f152999b to nil")
	}
	if err := b.ConsumeID(TestVectorIntObjectTypeID); err != nil {
		return fmt.Errorf("unable to decode testVectorIntObject#f152999b: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode testVectorIntObject#f152999b: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value TestInt
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode testVectorIntObject#f152999b: field value: %w", err)
			}
			t.Value = append(t.Value, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TestVectorIntObject.
var (
	_ bin.Encoder = &TestVectorIntObject{}
	_ bin.Decoder = &TestVectorIntObject{}
)

// A simple object containing a vector of strings; for testing only
type TestVectorString struct {
	// Vector of strings
	Value []string
}

// TestVectorStringTypeID is TL type id of TestVectorString.
const TestVectorStringTypeID = 0x5d6f85bc

// Encode implements bin.Encoder.
func (t *TestVectorString) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testVectorString#5d6f85bc as nil")
	}
	b.PutID(TestVectorStringTypeID)
	b.PutVectorHeader(len(t.Value))
	for _, v := range t.Value {
		b.PutString(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TestVectorString) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testVectorString#5d6f85bc to nil")
	}
	if err := b.ConsumeID(TestVectorStringTypeID); err != nil {
		return fmt.Errorf("unable to decode testVectorString#5d6f85bc: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode testVectorString#5d6f85bc: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode testVectorString#5d6f85bc: field value: %w", err)
			}
			t.Value = append(t.Value, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TestVectorString.
var (
	_ bin.Encoder = &TestVectorString{}
	_ bin.Decoder = &TestVectorString{}
)

// A simple object containing a vector of objects that hold a string; for testing only
type TestVectorStringObject struct {
	// Vector of objects
	Value []TestString
}

// TestVectorStringObjectTypeID is TL type id of TestVectorStringObject.
const TestVectorStringObjectTypeID = 0xe5ecc0d

// Encode implements bin.Encoder.
func (t *TestVectorStringObject) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testVectorStringObject#e5ecc0d as nil")
	}
	b.PutID(TestVectorStringObjectTypeID)
	b.PutVectorHeader(len(t.Value))
	for idx, v := range t.Value {
		if err := v.Encode(b); err != nil {
			return fmt.Errorf("unable to encode testVectorStringObject#e5ecc0d: field value element with index %d: %w", idx, err)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TestVectorStringObject) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testVectorStringObject#e5ecc0d to nil")
	}
	if err := b.ConsumeID(TestVectorStringObjectTypeID); err != nil {
		return fmt.Errorf("unable to decode testVectorStringObject#e5ecc0d: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode testVectorStringObject#e5ecc0d: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value TestString
			if err := value.Decode(b); err != nil {
				return fmt.Errorf("unable to decode testVectorStringObject#e5ecc0d: field value: %w", err)
			}
			t.Value = append(t.Value, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TestVectorStringObject.
var (
	_ bin.Encoder = &TestVectorStringObject{}
	_ bin.Decoder = &TestVectorStringObject{}
)

// A simple object containing a vector of bytes.
type TestVectorBytes struct {
	// Value field of TestVectorBytes.
	Value [][]byte
}

// TestVectorBytesTypeID is TL type id of TestVectorBytes.
const TestVectorBytesTypeID = 0xa590fb25

// Encode implements bin.Encoder.
func (t *TestVectorBytes) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testVectorBytes#a590fb25 as nil")
	}
	b.PutID(TestVectorBytesTypeID)
	b.PutVectorHeader(len(t.Value))
	for _, v := range t.Value {
		b.PutBytes(v)
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TestVectorBytes) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testVectorBytes#a590fb25 to nil")
	}
	if err := b.ConsumeID(TestVectorBytesTypeID); err != nil {
		return fmt.Errorf("unable to decode testVectorBytes#a590fb25: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode testVectorBytes#a590fb25: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			value, err := b.Bytes()
			if err != nil {
				return fmt.Errorf("unable to decode testVectorBytes#a590fb25: field value: %w", err)
			}
			t.Value = append(t.Value, value)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TestVectorBytes.
var (
	_ bin.Encoder = &TestVectorBytes{}
	_ bin.Decoder = &TestVectorBytes{}
)

// TestVectorVector represents TL type testVectorVector#69e8846c.
type TestVectorVector struct {
	// Value field of TestVectorVector.
	Value [][]string
}

// TestVectorVectorTypeID is TL type id of TestVectorVector.
const TestVectorVectorTypeID = 0x69e8846c

// Encode implements bin.Encoder.
func (t *TestVectorVector) Encode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't encode testVectorVector#69e8846c as nil")
	}
	b.PutID(TestVectorVectorTypeID)
	b.PutVectorHeader(len(t.Value))
	for _, row := range t.Value {
		b.PutVectorHeader(len(row))
		for _, v := range row {
			b.PutString(v)
		}
	}
	return nil
}

// Decode implements bin.Decoder.
func (t *TestVectorVector) Decode(b *bin.Buffer) error {
	if t == nil {
		return fmt.Errorf("can't decode testVectorVector#69e8846c to nil")
	}
	if err := b.ConsumeID(TestVectorVectorTypeID); err != nil {
		return fmt.Errorf("unable to decode testVectorVector#69e8846c: %w", err)
	}
	{
		headerLen, err := b.VectorHeader()
		if err != nil {
			return fmt.Errorf("unable to decode testVectorVector#69e8846c: field value: %w", err)
		}
		for idx := 0; idx < headerLen; idx++ {
			innerLen, err := b.VectorHeader()
			if err != nil {
				return fmt.Errorf("unable to decode testVectorVector#69e8846c: field value: %w", err)
			}
			var row []string
			for innerIndex := 0; innerIndex < innerLen; innerLen++ {
				value, err := b.String()
				if err != nil {
					return fmt.Errorf("unable to decode testVectorVector#69e8846c: field value: %w", err)
				}
				row = append(row, value)
			}
			t.Value = append(t.Value, row)
		}
	}
	return nil
}

// Ensuring interfaces in compile-time for TestVectorVector.
var (
	_ bin.Encoder = &TestVectorVector{}
	_ bin.Decoder = &TestVectorVector{}
)

// Bool represents Bool generic type.
//
// Example:
//  g, err := DecodeBool(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *False: // false#bc799737
//  case *True: // true#997275b5
//  default: panic(v)
//  }
type Bool interface {
	bin.Encoder
	bin.Decoder
	construct() Bool
}

// DecodeBool implements binary de-serialization for Bool.
func DecodeBool(buf *bin.Buffer) (Bool, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case FalseTypeID:
		// Decoding false#bc799737.
		v := False{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode Bool: %w", err)
		}
		return &v, nil
	case TrueTypeID:
		// Decoding true#997275b5.
		v := True{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode Bool: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode Bool: %w", bin.NewUnexpectedID(id))
	}
}

// Response represents Response generic type.
//
// Example:
//  g, err := DecodeResponse(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *ResponseID: // responseID#85d7fd8b
//  case *ResponseText: // responseText#cb0244f2
//  default: panic(v)
//  }
type Response interface {
	bin.Encoder
	bin.Decoder
	construct() Response
}

// DecodeResponse implements binary de-serialization for Response.
func DecodeResponse(buf *bin.Buffer) (Response, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case ResponseIDTypeID:
		// Decoding responseID#85d7fd8b.
		v := ResponseID{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode Response: %w", err)
		}
		return &v, nil
	case ResponseTextTypeID:
		// Decoding responseText#cb0244f2.
		v := ResponseText{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode Response: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode Response: %w", bin.NewUnexpectedID(id))
	}
}

// AbstractMessage represents AbstractMessage generic type.
//
// Example:
//  g, err := DecodeAbstractMessage(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *BigMessage: // bigMessage#7490dcc5
//  case *NoMessage: // noMessage#ee6324c4
//  case *TargetsMessage: // targetsMessage#cc6136f1
//  case *FieldsMessage: // fieldsMessage#947225b5
//  case *BytesMessage: // bytesMessage#f990a67d
//  default: panic(v)
//  }
type AbstractMessage interface {
	bin.Encoder
	bin.Decoder
	construct() AbstractMessage
}

// DecodeAbstractMessage implements binary de-serialization for AbstractMessage.
func DecodeAbstractMessage(buf *bin.Buffer) (AbstractMessage, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case BigMessageTypeID:
		// Decoding bigMessage#7490dcc5.
		v := BigMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode AbstractMessage: %w", err)
		}
		return &v, nil
	case NoMessageTypeID:
		// Decoding noMessage#ee6324c4.
		v := NoMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode AbstractMessage: %w", err)
		}
		return &v, nil
	case TargetsMessageTypeID:
		// Decoding targetsMessage#cc6136f1.
		v := TargetsMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode AbstractMessage: %w", err)
		}
		return &v, nil
	case FieldsMessageTypeID:
		// Decoding fieldsMessage#947225b5.
		v := FieldsMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode AbstractMessage: %w", err)
		}
		return &v, nil
	case BytesMessageTypeID:
		// Decoding bytesMessage#f990a67d.
		v := BytesMessage{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode AbstractMessage: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode AbstractMessage: %w", bin.NewUnexpectedID(id))
	}
}

// TextEntityType represents TextEntityType generic type.
//
// Example:
//  g, err := DecodeTextEntityType(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
//  case *TextEntityTypeMention: // textEntityTypeMention#37b3df65
//  case *TextEntityTypeHashtag: // textEntityTypeHashtag#c2f7a2dd
//  case *TextEntityTypeCashtag: // textEntityTypeCashtag#48e4374b
//  case *TextEntityTypeBotCommand: // textEntityTypeBotCommand#bb652bb3
//  case *TextEntityTypeUrl: // textEntityTypeUrl#b1c0d47c
//  case *TextEntityTypeEmailAddress: // textEntityTypeEmailAddress#54f81821
//  case *TextEntityTypePhoneNumber: // textEntityTypePhoneNumber#bad9aa2a
//  case *TextEntityTypeBankCardNumber: // textEntityTypeBankCardNumber#6513910
//  case *TextEntityTypeBold: // textEntityTypeBold#bcc0e1b0
//  case *TextEntityTypeItalic: // textEntityTypeItalic#f8f3965d
//  case *TextEntityTypeUnderline: // textEntityTypeUnderline#2f39cf92
//  case *TextEntityTypeStrikethrough: // textEntityTypeStrikethrough#394fc4fa
//  case *TextEntityTypeCode: // textEntityTypeCode#c5e9c94a
//  case *TextEntityTypePre: // textEntityTypePre#62491c8e
//  case *TextEntityTypePreCode: // textEntityTypePreCode#c7a77aab
//  case *TextEntityTypeTextUrl: // textEntityTypeTextUrl#1a912463
//  case *TextEntityTypeMentionName: // textEntityTypeMentionName#d0d2685d
//  default: panic(v)
//  }
type TextEntityType interface {
	bin.Encoder
	bin.Decoder
	construct() TextEntityType
}

// DecodeTextEntityType implements binary de-serialization for TextEntityType.
func DecodeTextEntityType(buf *bin.Buffer) (TextEntityType, error) {
	id, err := buf.PeekID()
	if err != nil {
		return nil, err
	}
	switch id {
	case TextEntityTypeMentionTypeID:
		// Decoding textEntityTypeMention#37b3df65.
		v := TextEntityTypeMention{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeHashtagTypeID:
		// Decoding textEntityTypeHashtag#c2f7a2dd.
		v := TextEntityTypeHashtag{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeCashtagTypeID:
		// Decoding textEntityTypeCashtag#48e4374b.
		v := TextEntityTypeCashtag{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeBotCommandTypeID:
		// Decoding textEntityTypeBotCommand#bb652bb3.
		v := TextEntityTypeBotCommand{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeUrlTypeID:
		// Decoding textEntityTypeUrl#b1c0d47c.
		v := TextEntityTypeUrl{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeEmailAddressTypeID:
		// Decoding textEntityTypeEmailAddress#54f81821.
		v := TextEntityTypeEmailAddress{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypePhoneNumberTypeID:
		// Decoding textEntityTypePhoneNumber#bad9aa2a.
		v := TextEntityTypePhoneNumber{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeBankCardNumberTypeID:
		// Decoding textEntityTypeBankCardNumber#6513910.
		v := TextEntityTypeBankCardNumber{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeBoldTypeID:
		// Decoding textEntityTypeBold#bcc0e1b0.
		v := TextEntityTypeBold{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeItalicTypeID:
		// Decoding textEntityTypeItalic#f8f3965d.
		v := TextEntityTypeItalic{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeUnderlineTypeID:
		// Decoding textEntityTypeUnderline#2f39cf92.
		v := TextEntityTypeUnderline{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeStrikethroughTypeID:
		// Decoding textEntityTypeStrikethrough#394fc4fa.
		v := TextEntityTypeStrikethrough{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeCodeTypeID:
		// Decoding textEntityTypeCode#c5e9c94a.
		v := TextEntityTypeCode{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypePreTypeID:
		// Decoding textEntityTypePre#62491c8e.
		v := TextEntityTypePre{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypePreCodeTypeID:
		// Decoding textEntityTypePreCode#c7a77aab.
		v := TextEntityTypePreCode{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeTextUrlTypeID:
		// Decoding textEntityTypeTextUrl#1a912463.
		v := TextEntityTypeTextUrl{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	case TextEntityTypeMentionNameTypeID:
		// Decoding textEntityTypeMentionName#d0d2685d.
		v := TextEntityTypeMentionName{}
		if err := v.Decode(buf); err != nil {
			return nil, fmt.Errorf("unable to decode TextEntityType: %w", err)
		}
		return &v, nil
	default:
		return nil, fmt.Errorf("unable to decode TextEntityType: %w", bin.NewUnexpectedID(id))
	}
}

// Client describes RPC methods of TL schema.
type Client interface {
	Ping(ctx context.Context, id int32) error
	Send(ctx context.Context, msg SMS) (SMS, error)
	SendMultipleSMS(ctx context.Context, messages []SMS) error
}
