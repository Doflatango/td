{{ define "main" }}
{{ $pkg := $.Package }}
{{ template "header" $ }}

{{ range $s:= $.Structs }}
// {{ $s.Comment }}
type {{ $s.Name }} struct {
{{- range $f := $s.Fields }}
    // {{ $f.Comment }}
{{- if and ($f.Conditional) (not $f.ConditionalBool) }}
//
// Use Set{{ $f.Name }} and Get{{ $f.Name }} helpers.
{{- end }}
    {{- if $f.DoubleSlice }}
    {{ $f.Name }} [][]{{ $f.Type }}
    {{- else if $f.Slice }}
    {{ $f.Name }} []{{ $f.Type }}
    {{- else }}
    {{ $f.Name }} {{ $f.Type }}
    {{- end }}
{{- end }}
}

// {{ $s.Name }}TypeID is TL type id of {{ $s.Name }}.
const {{ $s.Name }}TypeID = 0x{{ $s.HexID }};

// Encode implements bin.Encoder.
func ({{ $s.Receiver }} *{{ $s.Name }}) Encode({{ $s.BufArg }} *bin.Buffer) error {
    if {{ $s.Receiver }} == nil {
        return fmt.Errorf("can't encode {{ $s.TLType }} as nil")
    }
{{ $s.BufArg }}.PutID({{ $s.Name }}TypeID)
{{- range $f := $s.Fields }}
    {{- if not $f.ConditionalBool }}
    {{- if $f.Conditional }}
    if {{ $s.Receiver }}.{{ $f.ConditionalField }}.Has({{ $f.ConditionalIndex }}) {
    {{- end }}
    {{- if $f.Vector }}
    {{ $s.BufArg }}.PutVectorHeader(len({{ $s.Receiver }}.{{ $f.Name }}))
    for {{ if $f.Encoder }}idx{{ else }}_{{ end }}, {{- if $f.DoubleVector }}row{{else}}v{{end}} := range {{ $s.Receiver }}.{{ $f.Name }} {
    {{- if $f.DoubleVector }}
        {{ $s.BufArg }}.PutVectorHeader(len(row))
        for _, v := range row {
    {{- end }}
    {{- if $f.Encoder }}
        {{- if $f.Generic }}
            if v == nil {
            return fmt.Errorf("unable to encode {{ $s.TLType }}: field {{ $f.TLName }} element with index %d is nil", idx)
            }
        {{- end}}
        if err := v.Encode({{ $s.BufArg }}); err != nil {
            return fmt.Errorf("unable to encode {{ $s.TLType }}: field {{ $f.TLName }} element with index %d: %w", idx, err)
        }
    {{- else }}
        {{ $s.BufArg }}.Put{{ $f.Func }}(v)
    {{- end }}
    {{- if $f.DoubleVector }}
        }
    {{- end }}
    }
    {{- else }}
    {{- if $f.Encoder }}
    {{- if $f.Generic }}
    if {{ $s.Receiver }}.{{ $f.Name }} == nil {
        return fmt.Errorf("unable to encode {{ $s.TLType }}: field {{ $f.TLName }} is nil")
    }
    {{- end}}
    if err := {{ $s.Receiver }}.{{ $f.Name }}.Encode({{ $s.BufArg }}); err != nil {
        return fmt.Errorf("unable to encode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
    }
    {{- else }}
    {{ $s.BufArg }}.Put{{ $f.Func }}({{ $s.Receiver }}.{{ $f.Name }})
    {{- end }}
    {{- end }}
    {{- if $f.Conditional }}
    }
    {{- end }}
    {{- end }}
{{- end }}
    return nil
}

{{- range $f := $s.Fields }}
{{ if $f.Conditional }}
// Set{{ $f.Name }} sets value of {{ $f.Name }} conditional field.
func ({{ $s.Receiver }} *{{ $s.Name }}) Set{{ $f.Name }}(value {{ $f.Type }}) {
{{- if $f.ConditionalBool }}
    if value {
        {{ $s.Receiver }}.{{ $f.ConditionalField }}.Set({{ $f.ConditionalIndex }})
    } else {
        {{ $s.Receiver }}.{{ $f.ConditionalField }}.Unset({{ $f.ConditionalIndex }})
    }
{{- else }}
    {{ $s.Receiver }}.{{ $f.ConditionalField }}.Set({{ $f.ConditionalIndex }})
    {{ $s.Receiver }}.{{ $f.Name }} = value
{{- end }}
}

{{- if not $f.ConditionalBool }}
// Get{{ $f.Name }} returns value of {{ $f.Name }} conditional field and
// boolean which is true if field was set.
func ({{ $s.Receiver }} *{{ $s.Name }}) Get{{ $f.Name }}() (value {{ $f.Type }}, ok bool) {
    if !{{ $s.Receiver }}.{{ $f.ConditionalField }}.Has({{ $f.ConditionalIndex }}) {
        return value, false
    }
    return {{ $s.Receiver }}.{{ $f.Name }}, true
}

{{- end }}

{{- end }}
{{- end }}

// Decode implements bin.Decoder.
func ({{ $s.Receiver }} *{{ $s.Name }}) Decode({{ $s.BufArg }} *bin.Buffer) error {
    if {{ $s.Receiver }} == nil {
        return fmt.Errorf("can't decode {{ $s.TLType }} to nil")
    }
    if err := {{ $s.BufArg }}.ConsumeID({{ $s.Name }}TypeID); err != nil {
        return fmt.Errorf("unable to decode {{ $s.TLType }}: %w", err)
    }
{{- range $f := $s.Fields }}
    {{- if $f.ConditionalBool }}
        {{ $s.Receiver }}.{{ $f.Name }} = {{ $s.Receiver }}.{{ $f.ConditionalField }}.Has({{ $f.ConditionalIndex }})
    {{- else }}
        {{- if $f.Conditional}}
            if {{ $s.Receiver }}.{{ $f.ConditionalField }}.Has({{ $f.ConditionalIndex }}) {
        {{- else}}
            {
        {{- end }}
        {{- if $f.Vector }}
            headerLen, err := {{ $s.BufArg }}.VectorHeader()
            if err != nil {
                return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
            }
            for idx := 0; idx < headerLen; idx++ {

            {{- if $f.DoubleVector }}
                innerLen, err := {{ $s.BufArg }}.VectorHeader()
                if err != nil {
                    return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
                }
                var row []{{ $f.Type }}
                for innerIndex := 0; innerIndex < innerLen; innerLen++ {
            {{- end }}
            {{- if $f.Generic }}
                value, err := Decode{{ $f.Type }}({{ $s.BufArg }})
                if err != nil {
                    return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
                }
            {{- else if $f.Encoder }}
                var value {{ $f.Type }}
                if err := value.Decode({{ $s.BufArg }}); err != nil {
                    return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
                }
            {{- else}}
                value, err := {{ $s.BufArg }}.{{ $f.Func }}()
                if err != nil {
                    return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
                }
            {{- end }}
                {{- if $f.DoubleVector }}
                    row = append(row, value)
                }
                {{ $s.Receiver }}.{{ $f.Name }} = append({{ $s.Receiver }}.{{ $f.Name }}, row)
                {{- else }}
                {{ $s.Receiver }}.{{ $f.Name }} = append({{ $s.Receiver }}.{{ $f.Name }}, value)
                {{- end }}
            }
        {{- else }}
        {{- if $f.Generic }}
            value, err := Decode{{ $f.Type }}({{ $s.BufArg }})
            if err != nil {
                return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
            }
            {{ $s.Receiver }}.{{ $f.Name }} = value
        {{- else if $f.Encoder }}
            if err := {{ $s.Receiver }}.{{ $f.Name }}.Decode({{ $s.BufArg }}); err != nil {
                return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
            }
        {{- else }}
            value, err := {{ $s.BufArg }}.{{ $f.Func }}()
            if err != nil {
                return fmt.Errorf("unable to decode {{ $s.TLType }}: field {{ $f.TLName }}: %w", err)
            }
            {{ $s.Receiver }}.{{ $f.Name }} = value
        {{- end }}
        {{- end }}
    }
    {{- end }}
{{- end }}
    return nil
}

{{ if $s.Constructor }}
// construct implements constructor of {{ $s.Interface }}.
func ({{ $s.Receiver }} {{ $s.Name }}) construct() {{ $s.Interface }} { return &{{ $s.Receiver }} }
{{ end }}

// Ensuring interfaces in compile-time for {{ $s.Name }}.
var (
_ bin.Encoder = &{{ $s.Name }}{}
_ bin.Decoder = &{{ $s.Name }}{}
{{ if $s.Constructor }}
_ {{ $s.Interface }} = &{{ $s.Name }}{}
{{ end }}
)
{{ end }}

{{ range $f:= $.Interfaces }}
// {{ $f.Name }} represents {{ $f.Name }} generic type.
//
// Example:
//  g, err := Decode{{ $f.Name }}(buf)
//  if err != nil {
//      panic(err)
//  }
//  switch v := g.(type) {
{{ range $c := $f.Constructors -}}
//  case *{{ $c.Name }}: // {{ $c.TLType }}
{{ end -}}
//  default: panic(v)
//  }
type {{ $f.Name }} interface {
    bin.Encoder
    bin.Decoder
    construct() {{ $f.Name }}
}

// Decode{{ $f.Name }} implements binary de-serialization for {{ $f.Name }}.
func Decode{{ $f.Name }} (buf *bin.Buffer) ({{ $f.Name }}, error) {
    id, err := buf.PeekID()
    if err != nil {
        return nil, err
    }
    switch id {
    {{- range $c := $f.Constructors }}
    case {{ $c.Name }}TypeID:
        // Decoding {{ $c.TLType }}.
        v := {{ $c.Name }}{}
        if err := v.Decode(buf); err != nil {
            return nil, fmt.Errorf("unable to decode {{ $f.Name }}: %w", err)
        }
        return &v, nil
    {{- end }}
    default:
        return nil, fmt.Errorf("unable to decode {{ $f.Name }}: %w", bin.NewUnexpectedID(id))
    }
}

{{ end }}

{{ if $.RPC }}
// Client describes RPC methods of TL schema.
type Client interface {
{{ range $m := $.Methods }}
{{ $m.Name }} (ctx context.Context
{{- range $a := $m.Arguments  -}}, {{ $a.Name }} {{ if $a.DoubleSlice }}[][]{{ else if $a.Slice }}[]{{ end }}{{ $a.Type }}{{- end -}}) {{- if not $m.Result.Blank -}}
({{- if $m.Result.Slice }}[]{{ end }}{{ $m.Result.Type }}, error)
{{- else -}}
error
{{- end -}}
{{ end }}
}


{{ end }}

{{ end }}
